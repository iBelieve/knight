{"version":3,"sources":["stdin"],"names":["Symbol","name","js/this","Keyword","not","value","nil?","not-nil?","symbol?","keyword?","number?","js/Number","neg","string?","js/String","list?","js/Array","isArray","empty?","length","not-empty?","list","items","map","array","func","map-last","last-func","item","index","append","concat","a","b","string-prefix?","string","prefix","startsWith","string-suffix?","endsWith","hash-map","js/Map","hash-map-get","key","get","hash-map-set!","set","hash-map-copy","contains-key?","has","interned-symbols","interned-keywords","string->symbol","symbol->string","symbol","keyword->string","keyword","first","second","skip1","slice","skip2","regex","str","flags","js/RegExp","error","msg","js/Error","tagged-list?","tag","repr","js/JSON","stringify","grouped","seq","count","i","zip","arrays","_","unbox","valueOf","symbol-meta","js/Symbol","meta","string-repeat","repeat","string-pad-start","width","filler","padStart","toString","make-string-reader","reader-macros","reader-pos","reader","offset","line-break","line","cur","lastindex","match","exec","input","reader-indent-warning","start-index","end-char","pos","indentWarnings","push","reader-unterminated-error","start-pos","warning","predicate","w","startIndex","find","js/console","marked-line","read-char","char","peek-char","has-more?","char-whitespace?","char-digit?","char-macro?","take-until","input-length","substring","take-while","skip-whitespace","c","read-token","parse-token","token","string->keyword","read-number","includes","string-contains?","js/parseFloat","js/parseInt","read-unmatched-delimiter","first-char","read-unicode-char","d","fromCharCode","line-index","before-line-index","after-line-index","lines","split","before-line","after-line","caret-line","column","line-num","before-line-num","after-line-num","max-line-num-width","values","js/Math","max","read-until","has-indent-error","start-line","start-indent","results","last-pos","indent","read-syntax","read","macro","form","end-pos","meta-set!","string2","ch","escaped-char","js-keywords","js/Set","emit-specials","field-access?","expression?","node","type","compiler-error","loc","source","start","child-env","env","variables","loopVariables","from","kebabcase->camelcase","ident","replace","replace-special-chars","p1","toUpperCase","sanitize-js-keywords","set-contains?","js-keyword?","symbol->ident","define-variable","isLoop","resolve-var","define-function","statement->expression","statement->return","statement->iife","expression","nodes","body","test","consequent","alternate","emit-return-last","forms","emit-statement","emit","emit-return-statement","emit-return-block","emit-statements","emit-expressions","emit-expression","emit-patterns","emit-pattern","emit-block","single?","emit-var","callee","args","field-name","obj","emit-field","method-call?","method-name","method-args","emit-methodcall","special?","emit-funcall","emit-list","emit-literal","js/undefined","emit-return","emit-bin-op","op","reduce","acc","arg","emit-vars","vars","pair","knight-quote","params","rest","func-env","setter","emit-set-var","emit-set-field","emit-set-index","emit-setter","if-true","if-false","var","for-env","let-env","emit-branch","expr","loop-env","recur-env","ctx","js/require","fs","escodegen","terser","program","option","parse","js/process","argv","output-filename","output","source-map-filename","code","readFileSync","ast","emit-module","read-many","generate","source-map","minified","minify","writeFileSync","log","println"],"mappings":"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","sourcesContent":["; -*- mode: Clojure -*-\n\n(defn Symbol [name]\n  (set! (.-name js/this) name)\n  (js/return))\n\n(defn Keyword [name]\n  (set! (.-name js/this) name)\n  (js/return))\n\n(defn true? [value]\n  (js/=== value true))\n\n(defn false? [value]\n  (js/=== value false))\n\n(defn truthy? [value]\n  \"A value is considered truthy if it is not false and not nil (i.e., not falsy)\"\n  (js/and (js/!== value false) (js/!= value nil)))\n\n(defn falsy? [value]\n  \"A value is considered falsy if it is false or nil\"\n  (js/or (js/=== value false) (js/== value nil)))\n\n(defn not [value]\n  (js/or (js/=== value false) (js/== value nil)))\n\n(defn nil? [value]\n  (js/== value nil))\n\n(defn not-nil? [value]\n  (js/!= value nil))\n\n(defn symbol? [value]\n  (js/instanceof value Symbol))\n\n(defn keyword? [value]\n  (js/instanceof value Keyword))\n\n(defn bool? [value]\n  (js/or (js/=== (js/typeof value) \"boolean\")\n         (js/instanceof value js/Boolean)))\n\n(defn number? [value]\n  (js/or (js/=== (js/typeof value) \"number\")\n         (js/instanceof value js/Number)))\n\n(defn positive? [value]\n  (and (number? value)\n       (> value 0)))\n\n(defn negative? [value]\n  (and (number? value)\n       (< value 0)))\n\n(defn neg [value]\n  (* -1 value))\n\n(defn char? [value]\n  (js/and (js/or (js/=== (js/typeof value) \"string\")\n                 (js/instanceof value js/String))\n          (js/=== (.-length value) 1)))\n\n(defn string? [value]\n  (js/or (js/=== (js/typeof value) \"string\")\n         (js/instanceof value js/String)))\n\n(defn list? [value]\n  (.isArray js/Array value))\n\n(defn empty? [value]\n  (js/=== (.-length value) 0))\n\n(defn single? [list]\n  (and (list? list)\n       (= (.-length list) 1)))\n\n(defn not-empty? [value]\n  (and (not-nil? value)\n       (> (.-length value) 0)))\n\n(defn list [(spread items)]\n  (js/array (spread items)))\n\n(defn map [array func]\n  (.map array func))\n\n(defn map-last [array func last-func]\n  (.map array\n        (fn [item index]\n          (if (= index (- (.-length array) 1))\n            (last-func item)\n            (if (nil? func)\n              item\n              (func item))))))\n\n(defn append [list (spread items)]\n  (js/array (spread list) (spread items)))\n\n(defn concat [a b]\n  (+ a b))\n\n(defn string-contains? [string substring]\n  (.includes string substring))\n\n(defn string-prefix? [string prefix]\n  (.startsWith string prefix))\n\n(defn string-suffix? [string prefix]\n  (.endsWith string prefix))\n\n(defn string-join [string sep]\n  (.join string sep))\n\n; (defn parse-float [string]\n;   (js/parseFloat string))\n\n; (defn parse-int [string]\n;   (js/parseInt string))\n\n(defn println [(spread args)]\n  (.log js/console (spread args)))\n\n(defn print [(spread args)]\n  (for [arg args]\n    (.write (.-stdout js/process) arg)))\n\n(defn hash-map []\n  (js/new js/Map))\n\n(defn hash-map-get [map key]\n  (.get map key))\n\n(defn hash-map-set! [map key value]\n  (.set map key value))\n\n(defn hash-map-copy [map]\n  (js/new js/Map map))\n\n(defn array-copy [array]\n  (.from js/Array array))\n\n(defn contains-key? [map key]\n  (.has map key))\n\n(def interned-symbols (hash-map))\n(def interned-keywords (hash-map))\n\n(defn string->symbol [string]\n  (if (not (contains-key? interned-symbols string))\n    (hash-map-set! interned-symbols string (js/new Symbol string)))\n  (hash-map-get interned-symbols string))\n\n(defn symbol->string [symbol]\n  (.-name symbol))\n\n(defn keyword->string [keyword]\n  (.-name keyword))\n\n(defn string->keyword [string]\n  (let [substring (if (string-prefix? string \":\")\n                    (.substring string 1)\n                    (if (string-suffix? string \":\")\n                      (.substring string 0 (- (.-length string) 1))\n                      string))]\n    (if (not (contains-key? interned-keywords substring))\n      (hash-map-set! interned-keywords substring (js/new Keyword substring)))\n    (hash-map-get interned-keywords substring)))\n\n(defn first [list]\n  (js/index list 0))\n\n(defn second [list]\n  (js/index list 1))\n\n(defn third [list]\n  (js/index list 2))\n\n(defn fourth [list]\n  (js/index list 3))\n\n(defn skip1 [list]\n  (.slice list 1))\n\n(defn skip2 [list]\n  (.slice list 2))\n\n(defn split-last [seq]\n  (js/array (.slice seq 0 (- (.-length seq) 1))\n            (js/index seq (- (.-length seq) 1))))\n\n(defn regex [str flags]\n  (js/new js/RegExp str flags))\n\n(defn error [msg]\n  (js/throw (js/new js/Error msg)))\n\n(defn tagged-list? [value tag]\n  (and (list? value)\n       (= (first value) tag)))\n\n(defn repr [value]\n  (cond\n    [(nil? value) \"nil\"]\n    [else (.stringify js/JSON value)]))\n\n(defgen grouped [seq count]\n  (loop [i 0]\n    (if (< i (.-length seq))\n      (do\n        (yield (.slice seq i (+ i count)))\n        (recur (+ i count))))))\n\n(defn zip [(spread arrays)]\n  (map (first arrays)\n       (fn [_ index]\n         (map arrays (fn [array] (js/index array index))))))\n\n(defn set [(spread values)]\n  (js/new js/Set values))\n\n(defn set-contains? [set value]\n  (.has set value))\n\n(defn box [value]\n  (cond\n    [(bool? value) (js/new js/Boolean value)]\n    [(number? value) (js/new js/Number value)]\n    [(string? value) (js/new js/String value)]\n    [else value]))\n\n(defn unbox [value]\n  (if (not-nil? value)\n    (.valueOf value)\n    nil))\n\n(def symbol-meta (js/Symbol \"meta\"))\n\n(defn meta [value]\n  (js/index value symbol-meta))\n\n(defn meta-set! [value meta]\n  (set! (js/index value symbol-meta) meta)\n  (js/return))\n\n(defn string-repeat [str count]\n  (.repeat str count))\n\n(defn string-pad-start [string width filler]\n  (.padStart string width filler))\n\n(defn string-pad-end [string width filler]\n  (.padEnd string width filler))\n\n(defn string [value]\n  (if (nil? value)\n    \"nil\"\n    (.toString value)))\n\n(defn max [(spread values)]\n  (.max js/Math (spread values)))\n\n(defn find-first [seq predicate]\n  (.find seq predicate))\n; -*- mode: Clojure -*-\n\n(defn make-string-reader [string]\n  {input: string,\n   index: 0,\n   indent-warnings: (js/array)})\n\n(def reader-macros (hash-map))\n\n(defn reader-pos [reader offset]\n  (let [line-break (regex \"\\r\\n?|\\n\",\"g\"),\n        index (if (not-nil? offset)\n                (+ (.-index reader) offset)\n                (.-index reader))]\n    (loop [line 1,\n           cur 0]\n      (set! (.-lastindex line-break) cur)\n      (let [match (.exec line-break (.-input reader))]\n        (if (and match (< (.-index match) index))\n          (recur (+ line 1)\n                 (+ (.-index match) (.-length (js/index match 0))))\n          {line: line,\n           column: (- index cur)})))))\n\n(defn reader-indent [reader offset]\n  (.-column (reader-pos reader offset)))\n\n(defn reader-indent-warning [reader start-index end-char pos]\n  (.push (.-indentWarnings reader) {start-index: start-index, end-char: end-char, pos: pos}))\n\n(defn reader-unterminated-error [reader start-index start-pos end-char]\n  (let [warning (find-first (.-indentWarnings reader) (fn [w] (>= (.-startIndex w) start-index)))]\n    (.error js/console warning)\n    (error (+ \"Unexpected EOF, expected: '\" end-char \"'\\n\\n\"\n              \"Started here:\\n\"\n              (marked-line (.-input reader) start-pos) \"\\n\\n\"\n              \"Based on indent:\\n\"\n              (marked-line (.-input reader) (.-pos warning))))))\n\n(defn read-char [reader]\n  (let [char (js/index (.-input reader) (.-index reader))]\n    (set! (.-index reader) (+ (.-index reader) 1))\n    char))\n\n(defn peek-char [reader offset]\n  (js/index (.-input reader)\n            (if (not-nil? offset)\n                (+ (.-index reader) offset)\n                (.-index reader))))\n\n(defn has-more? [reader]\n  (< (.-index reader) (.-length (.-input reader))))\n\n(defn char-whitespace? [char]\n  (or (= char \\space)\n      (= char \\tab)\n      (= char \\newline)\n      (= char \\,)))\n\n(defn char-digit? [char]\n  (and (>= char \\0)\n       (<= char \\9)))\n\n(defn char-macro? [char]\n  (contains-key? reader-macros char))\n\n(defn take-until [reader predicate]\n  (let [start-index (.-index reader)\n        input-length (.-length (.-input reader))]\n    (loop [index (.-index reader)]\n      (if (or (>= index input-length)\n              (predicate (js/index (.-input reader) index)))\n        (do\n          (set! (.-index reader) index)\n          (.substring (.-input reader) start-index index))\n        (recur (+ index 1))))))\n\n(defn take-while [reader predicate]\n  (take-until reader (fn [char] (not (predicate char)))))\n\n(defn skip-whitespace [reader]\n  (loop []\n    (take-while reader (fn [char] (char-whitespace? char)))\n    (if (= (peek-char reader) \\;)\n      (do\n        (take-until reader (fn [c] (= c \\newline)))\n        (recur)))))\n\n(defn read-token [reader]\n  (concat (read-char reader)\n          (take-until reader (fn (c) (or (char-whitespace? c) (char-macro? c))))))\n\n(defn parse-token [token]\n  (cond\n    [(= token \"nil\") nil]\n    [(= token \"true\") true]\n    [(= token \"false\") false]\n    [(or (string-prefix? token \":\")\n         (string-suffix? token \":\")) (string->keyword token)]\n    [else (string->symbol token)]))\n\n(defn read-number [reader]\n  (let [string (read-token reader)]\n    (if (string-contains? string \".\")\n      (js/parseFloat string)\n      (js/parseInt string))))\n\n(defn read-character [reader]\n  (let [char (read-token reader)]\n    (cond\n      [(= char \"newline\") \\newline]\n      [(= char \"return\") \\return]\n      [(= char \"tab\") \\tab]\n      [(= char \"space\") \\space]\n      [(= (.-length char) 1) char]\n      [else (error (+ \"Unrecognized char: '\" char \"'\"))])))\n\n(defn read-quote [reader]\n  (list 'quote (read reader)))\n\n(defn read-list [reader first-char]\n  (read-until reader \\)))\n\n(defn read-array [reader first-char]\n  (read-until reader \\]))\n\n(defn read-struct [reader first-char]\n  (list 'dict (spread (read-until reader \\}))))\n\n(defn read-unmatched-delimiter [reader first-char]\n  (error (concat \"Unmatched delimiter: \" first-char)))\n\n(defn read-string [reader first-char]\n  (loop [string \"\"]\n    (let [part (take-until reader (fn [ch] (or (= ch \\\")\n                                               (= ch \\\\))))\n          string2 (concat string part)\n          char (read-char reader)]\n      (cond\n        [(nil? char) (error \"Unexpected EOF while reading string\")]\n        [(= char \\\") string2]\n        [(= char \\\\)\n         (let [char (read-char reader)\n               escaped-char (cond\n                              [(nil? char) (error \"Unexpected EOF while reading character escape\")]\n                              [(= char \\\") char]\n                              [(= char \\\\) char]\n                              [(= char \\/) char]\n                              [(= char \\n) \\newline]\n                              [(= char \\t) \\tab]\n                              [(= char \\r) \\return]\n                              [(= char \\u) (read-unicode-char reader)]\n                              [else (concat (error \"Unrecognized character escape\" char))])]\n           (recur (concat string2 escaped-char)))]))))\n\n(defn read-unicode-char [reader]\n  (let [a (read-char reader),\n        b (read-char reader),\n        c (read-char reader),\n        d (read-char reader)]\n    (.fromCharCode js/String (js/parseInt (+ a b c d)))))\n\n(hash-map-set! reader-macros \\' read-quote)\n(hash-map-set! reader-macros \\\\ read-character)\n(hash-map-set! reader-macros \\\" read-string)\n(hash-map-set! reader-macros \\( read-list)\n(hash-map-set! reader-macros \\) read-unmatched-delimiter)\n(hash-map-set! reader-macros \\[ read-array)\n(hash-map-set! reader-macros \\] read-unmatched-delimiter)\n(hash-map-set! reader-macros \\{ read-struct)\n(hash-map-set! reader-macros \\} read-unmatched-delimiter)\n\n(defn marked-line [input pos]\n  (let [line-index (- (.-line pos) 1),\n        before-line-index (- line-index 1),\n        after-line-index (+ line-index 1),\n        lines (.split input \\newline),\n        line (js/index lines line-index),\n        before-line (or (js/index lines before-line-index) \"\"),\n        after-line (or (js/index lines after-line-index) \"\"),\n        col (.-column pos),\n        caret-line (concat (string-repeat \" \" col) \"^\"),\n        line-num (string (+ line-index 1)),\n        before-line-num (string (+ before-line-index 1)),\n        after-line-num (string (+ after-line-index 1)),\n        max-line-num-width (max (.-length line-num)\n                                (.-length before-line-num)\n                                (.-length after-line-num))]\n    (+ (string-pad-start before-line-num max-line-num-width) \" \" before-line \"\\n\"\n       (string-pad-start line-num max-line-num-width) \" \" line \"\\n\"\n       (string-repeat \" \" max-line-num-width) \" \" caret-line \"\\n\"\n       (string-pad-start after-line-num max-line-num-width) \" \" after-line)))\n\n(defn reader-error [reader pos msg]\n  (error (+ msg \"\\n\\n\" (marked-line (.-input reader) pos))))\n\n(defn read-until [reader end-char]\n  (let [has-indent-error false,\n        start-index (- (.-index reader) 1)\n        start-pos (reader-pos reader -1),\n        start-line (.-line start-pos),\n        start-indent (.-column start-pos)]\n    (loop [results (list)]\n      (if (not has-indent-error)\n        (let [last-pos (reader-pos reader)]\n          (skip-whitespace reader)\n          (let [pos (reader-pos reader),\n                line (.-line pos),\n                indent (.-column pos)]\n            (if (and (> line start-line) (<= indent start-indent))\n              (do\n                (set! has-indent-error true)\n                (reader-indent-warning reader start-index end-char last-pos))))))\n      (let [char (peek-char reader)]\n        (cond\n          [(nil? char)\n           (reader-unterminated-error reader start-index start-pos end-char)]\n          [(= char end-char)\n           (read-char reader)\n           results]\n          [else (recur (append results (read-syntax reader)))])))))\n\n(defn read [reader]\n  (skip-whitespace reader)\n  (let [c (peek-char reader)]\n    (cond\n      [(char-digit? c) (read-number reader)]\n      [(char-macro? c)\n       (let [macro (hash-map-get reader-macros c)]\n         (read-char reader)\n         (macro reader c))]\n      [(and (or (= c \\+) (= c \\-))\n            (char-digit? (peek-char reader 1)))\n       (read-number reader)]\n      [else (parse-token (read-token reader))])))\n\n(defn read-syntax [reader]\n  (let [start-pos (reader-pos reader),\n        form (read reader),\n        end-pos (reader-pos reader)]\n    (if (not-nil? form)\n      (meta-set! form {loc: {source: (.-input reader),\n                             start: start-pos,\n                             end: end-pos}}))\n    form))\n\n(defn read-many [reader]\n  (loop [results (list)]\n    (skip-whitespace reader)\n    (if (has-more? reader)\n      (recur (append results (read-syntax reader)))\n      results)))\n\n(defn string->expr [str]\n  (read-syntax (make-string-reader str)))\n\n(defn string->exprs [str]\n  (read-many (make-string-reader str)))\n; -*- mode: Clojure -*-\n\n(def js-keywords (set \"var\" \"let\" \"const\"))\n\n(def emit-specials (hash-map))\n\n;; Predicates\n\n(defn field-access? [form]\n  (and (symbol? form)\n       (string-prefix? (symbol->string form) \".-\")))\n\n(defn method-call? [form]\n  (and (symbol? form)\n       (string-prefix? (symbol->string form) \".\")))\n\n(defn special? [form]\n  (and (symbol? form)\n       (contains-key? emit-specials form)))\n\n(defn js-keyword? [ident]\n  (set-contains? js-keywords ident))\n\n(defn expression? [node]\n  (let [type (.-type node)]\n    (or (= type \"Literal\")\n        (= type \"Identifier\")\n        (string-suffix? type \"Expression\")\n        (string-suffix? type \"Element\"))))\n\n;; Environment\n\n(defn compiler-error [form msg]\n  (if (and (meta form) (.-loc (meta form)))\n    (let [loc (.-loc (meta form)),\n          source (.-source loc),\n          pos (.-start loc)]\n      (error (+ msg \"\\n\\n\" (marked-line source pos))))\n    (error msg)))\n\n(defn make-env []\n  {variables: (hash-map),\n   is-loop: false})\n\n(defn child-env [env]\n  {variables: (hash-map-copy (.-variables env))\n   loop-variables: (if (not-nil? (.-loopVariables env))\n                     (array-copy (.-loopVariables env))),\n   is-loop: false})\n\n(defn recur-env [env]\n  {variables: (hash-map-copy (.-variables env))\n   loop-variables: (js/array),\n   is-loop: true})\n\n(defn replace-special-chars [ident]\n  (.replace (.replace (.replace (.replace ident \"!\" \"\")\n                                \"->\" \"-to-\")\n                      (regex \"^((contains|has).*)\\\\?$\") \"$1\")\n            (regex \"^(.*)\\\\?$\") \"is-$1\"))\n\n(defn kebabcase->camelcase [ident]\n  (.replace (replace-special-chars ident)\n            (regex \"[-_]([a-zA-Z])\" \"g\")\n            (fn [match p1] (.toUpperCase p1))))\n\n(defn sanitize-js-keywords [ident]\n  (if (js-keyword? ident)\n    (concat ident \"$\")\n    ident))\n\n(defn symbol->ident [symbol]\n  (cond\n    [(= symbol 'Symbol) \"LispSymbol\"]\n    [else (sanitize-js-keywords (kebabcase->camelcase (symbol->string symbol)))]))\n\n(defn define-variable [env symbol]\n  (let [variables (.-variables env)]\n    (if (not (contains-key? variables symbol))\n      (hash-map-set! variables symbol (symbol->ident symbol)))\n    (if (.-isLoop env)\n      (.push (.-loopVariables env) symbol))\n    (resolve-var env symbol)))\n\n(defn define-function [env symbol]\n  (let [variables (.-variables env)]\n    (if (not (contains-key? variables symbol))\n      (hash-map-set! variables symbol (symbol->ident symbol)))\n    (resolve-var env symbol)))\n\n(defn resolve-var [env symbol]\n  (let [variables (.-variables env),\n        string (symbol->string symbol),\n        loc (if (meta symbol) (.-loc (meta symbol)))]\n    (if (string-prefix? string \"js/\")\n      {type: \"Identifier\",\n       name: (.substring string 3),\n       originalName: string,\n       loc: loc}\n      (if (not (contains-key? variables symbol))\n        (compiler-error symbol (+ \"Symbol not found: \" string))\n        {type: \"Identifier\",\n         name: (hash-map-get variables symbol),\n         originalName: (symbol->string symbol),\n         loc: loc}))))\n\n;; AST Transformation\n\n(defn statement->iife [node]\n  {type: \"CallExpression\",\n   callee: {type: \"ArrowFunctionExpression\",\n            id: nil,\n            params: (js/array),\n            body: {type: \"BlockStatement\",\n                   body: (js/array (statement->return node)),\n                   loc: (.-loc node)}},\n   arguments: (js/array)})\n\n(defn statement->expression [node]\n  (statement->iife node))\n\n(defn statements->return [nodes]\n  (if (empty? nodes)\n    (js/array {:type \"ReturnStatement\",\n               :argument nil})\n    (map-last nodes nil statement->return)))\n\n(defn statement->return [node]\n  (let [type (.-type node)]\n    (cond\n      [(= type \"ReturnStatement\") node]\n      [(= type \"ForOfStatement\") node]\n      [(= type \"ContinueStatement\") node]\n      [(= type \"ThrowStatement\") node]\n      [(= type \"ExpressionStatement\")\n       {type: \"ReturnStatement\",\n        argument: (.-expression node),\n        loc: (.-loc node)}]\n      [(= type \"BlockStatement\")\n       {type: \"BlockStatement\",\n        body: (statements->return (.-body node)),\n        loc: (.-loc node)}]\n      [(= type \"WhileStatement\")\n       {type: \"WhileStatement\",\n        test: (.-test node),\n        body: (statement->return (.-body node)),\n        loc: (.-loc node)}]\n      [(= type \"IfStatement\")\n       {type: \"IfStatement\",\n        test: (.-test node),\n        consequent: (statement->return (.-consequent node)),\n        alternate: (if (.-alternate node)\n                       (statement->return (.-alternate node))\n                       nil),\n        loc: (.-loc node)}]\n      [else (error (concat \"Unsupported return statement: \" type))])))\n\n;; AST Generation of specific types\n\n(defn emit-return-last [env forms]\n  (map-last forms (fn [form] (emit-statement env form))\n                  (fn [form] (emit-return-statement env form))))\n\n(defn emit-return-block [env forms]\n  {type: \"BlockStatement\",\n   body: (emit-return-last env forms)})\n\n(defn emit-return-statement [env form]\n  (let [node (emit env form)]\n    (if (expression? node)\n      {type: \"ReturnStatement\",\n       argument: node,\n       loc: (.-loc node)}\n      (statement->return node))))\n\n(defn emit-statements [env forms]\n  (map forms (fn [form] (emit-statement env form))))\n\n(defn emit-statement [env form]\n  (let [node (emit env form)]\n    (if (expression? node)\n      {type: \"ExpressionStatement\",\n       expression: node,\n       loc: (.-loc node)}\n      node)))\n\n(defn emit-expressions [env forms]\n  (map forms (fn [form] (emit-expression env form))))\n\n(defn emit-expression [env form]\n  (let [node (emit env form)]\n    (if (expression? node)\n      node\n      (statement->expression node))))\n\n(defn emit-patterns [env forms]\n  (map forms (fn [form] (emit-pattern env form))))\n\n(defn emit-pattern [env form]\n  (cond\n    [(symbol? form)\n     (define-variable env form)]\n    [(tagged-list? form 'spread)\n     {type: \"RestElement\",\n      argument: (define-variable env (second form)),\n      loc: (.-loc (meta form))}]\n    [(list? form)\n     {type: \"ArrayPattern\",\n      elements: (emit-patterns env form)}]\n    [else (compiler-error form \"Unrecognized pattern\")]))\n\n(defn emit-block [env forms]\n  (if (single? forms)\n    (emit-statement env (first forms))\n    {type: \"BlockStatement\",\n     body: (emit-statements env forms)}))\n\n;; AST Generation\n\n(defn emit-module [forms]\n  (let [env (make-env)]\n    (for [form forms]\n      (if (tagged-list? form 'defn)\n        (define-variable env (second form))))\n    {type: \"Program\",\n     body: (emit-statements env forms)}))\n\n(defn emit [env form]\n  (cond\n    [(symbol? form) (emit-var env form)]\n    [(list? form) (emit-list env form)]\n    [else (emit-literal env form)]))\n\n(defn emit-literal [env form]\n  (cond\n    [(js/=== form js/undefined) (error \"Undefined!\")]\n    [(keyword? form) (emit env (list 'string->keyword (keyword->string form)))]\n    [(negative? form)\n     {type: \"UnaryExpression\",\n      operator: \"-\",\n      prefix: true,\n      argument: {type: \"Literal\",\n                 value: (neg (unbox form))},\n      loc: (if (and (not-nil? form) (meta form)) (.-loc (meta form)))}]\n    [else {type: \"Literal\",\n           value: (unbox form),\n           loc: (if (and (not-nil? form) (meta form)) (.-loc (meta form)))}]))\n\n(defn emit-var [env symbol]\n  (resolve-var env symbol))\n\n(defn emit-list [env form]\n  (let [loc (if (meta form) (.-loc (meta form))),\n        callee (first form),\n        args (skip1 form)]\n    (cond\n      [(field-access? callee) (emit-field env loc callee args)]\n      [(method-call? callee) (emit-methodcall env loc callee args)]\n      [(special? callee) ((hash-map-get emit-specials callee) env loc args)]\n      [else (emit-funcall env loc callee args)])))\n\n(defn emit-field [env loc callee args]\n  (let [field-name (.substring (symbol->string callee) 2)\n        obj (first args)]\n    {type: \"MemberExpression\",\n     object: (emit-expression env obj),\n     property: {type: \"Identifier\",\n                name: field-name,\n                loc: (.-loc (meta callee))},\n     computed: false,\n     loc: loc}))\n\n(defn emit-methodcall [env loc callee args]\n  (let [method-name (.substring (symbol->string callee) 1)\n        obj (first args)\n        method-args (skip1 args)]\n    {type: \"CallExpression\",\n     callee: {type: \"MemberExpression\",\n              object: (emit-expression env obj),\n              property: {type: \"Identifier\",\n                         name: method-name,\n                         loc: (.-loc (meta callee))},\n              computed: false},\n     arguments: (emit-expressions env method-args),\n     loc: loc}))\n\n(defn emit-funcall [env loc callee args]\n  {type: \"CallExpression\",\n   callee: (emit-expression env callee),\n   arguments: (emit-expressions env args),\n   loc: loc})\n\n(defn emit-defn [env loc args]\n  (let [ident (define-function env (first args))\n        params (second args)\n        rest (skip2 args)\n        docs (if (and (string? (first rest))\n                      (not-empty? (skip1 rest)))\n                 (first rest))\n        body (if docs (skip1 rest) rest)\n        func-env (child-env env)]\n    {type: \"FunctionDeclaration\",\n     id: ident,\n     params: (emit-patterns func-env params),\n     body: (emit-return-block func-env body),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'defn emit-defn)\n\n(defn emit-defgen [env loc args]\n  (let [ident (define-function env (first args))\n        params (second args)\n        rest (skip2 args)\n        docs (if (and (string? (first rest))\n                      (not-empty? (skip1 rest)))\n                 (first rest))\n        body (if docs (skip1 rest) rest)\n        func-env (child-env env)]\n    {type: \"FunctionDeclaration\",\n     id: ident,\n     params: (emit-patterns func-env params),\n     body: (emit-return-block func-env body),\n     generator: true,\n     loc: loc}))\n\n(hash-map-set! emit-specials 'defgen emit-defgen)\n\n(defn emit-return [env loc args]\n  {type: \"ReturnStatement\",\n   argument: (if (not-empty? args) (emit-expression env (first args))),\n   loc: loc})\n\n(hash-map-set! emit-specials 'return emit-return)\n\n(defn emit-set [env loc args]\n  (let [setter (first args)\n        value (second args)]\n    (cond\n      [(symbol? setter) (emit-set-var env loc setter value)]\n      [(list? setter) (emit-setter env loc setter value)]\n      [else (error (concat \"Invalid setter: \" (repr setter)))])))\n\n(defn emit-setter [env loc setter value]\n  (let [callee (first setter)\n        args (skip1 setter)]\n    (cond\n      [(field-access? callee) (emit-set-field env loc callee args value)]\n      [(= callee 'js/index) (emit-set-index env loc args value)]\n      [else (error (concat \"Invalid setter: \" (repr setter)))])))\n\n(defn emit-set-var [env loc symbol value]\n  {type: \"AssignmentExpression\",\n   operator: \"=\",\n   left: (resolve-var env symbol),\n   right: (emit-expression env value),\n   loc: loc})\n\n(defn emit-set-field [env loc symbol args value]\n  (let [field-name (.substring (symbol->string symbol) 2)\n        obj (first args)]\n    {type: \"AssignmentExpression\",\n     operator: \"=\",\n     left: {type: \"MemberExpression\",\n            object: (emit-expression env obj),\n            property: {type: \"Identifier\",\n                       name: field-name,\n                       loc: (.-loc (meta symbol))},\n            computed: false},\n     right: (emit-expression env value),\n     loc: loc}))\n\n(defn emit-set-index [env loc args value]\n  (let [obj (first args)\n        index (second args)]\n    {type: \"AssignmentExpression\",\n     operator: \"=\",\n     left: {type: \"MemberExpression\",\n            object: (emit-expression env obj),\n            property: (emit-expression env index),\n            computed: true},\n     right: (emit-expression env value),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'set! emit-set)\n\n(defn emit-bin-op [op]\n  (fn [env loc args]\n    (if (empty? args)\n      (error \"Empty operator expression\"))\n    (.reduce (emit-expressions env args)\n            (fn [acc, arg]\n              {type: \"BinaryExpression\",\n               operator: op,\n               left: acc,\n               right: arg,\n               loc: loc}))))\n\n(hash-map-set! emit-specials 'and (emit-bin-op \"&&\"))\n(hash-map-set! emit-specials 'or (emit-bin-op \"||\"))\n(hash-map-set! emit-specials 'js/and (emit-bin-op \"&&\"))\n(hash-map-set! emit-specials 'js/or (emit-bin-op \"||\"))\n(hash-map-set! emit-specials 'js/=== (emit-bin-op \"===\"))\n(hash-map-set! emit-specials 'js/!== (emit-bin-op \"!==\"))\n(hash-map-set! emit-specials 'js/== (emit-bin-op \"==\"))\n(hash-map-set! emit-specials 'js/!= (emit-bin-op \"!=\"))\n(hash-map-set! emit-specials '= (emit-bin-op \"===\"))\n(hash-map-set! emit-specials '!= (emit-bin-op \"!==\"))\n(hash-map-set! emit-specials '>= (emit-bin-op \">=\"))\n(hash-map-set! emit-specials '<= (emit-bin-op \"<=\"))\n(hash-map-set! emit-specials '> (emit-bin-op \">\"))\n(hash-map-set! emit-specials '< (emit-bin-op \"<\"))\n(hash-map-set! emit-specials '+ (emit-bin-op \"+\"))\n(hash-map-set! emit-specials '- (emit-bin-op \"-\"))\n(hash-map-set! emit-specials '* (emit-bin-op \"*\"))\n(hash-map-set! emit-specials '/ (emit-bin-op \"/\"))\n(hash-map-set! emit-specials 'mod (emit-bin-op \"%\"))\n(hash-map-set! emit-specials 'js/instanceof (emit-bin-op \"instanceof\"))\n\n(defn emit-spread [env loc args]\n  {type: \"SpreadElement\",\n   argument: (emit-expression env (first args)),\n   loc: loc})\n\n(hash-map-set! emit-specials 'spread emit-spread)\n\n(defn emit-array [env loc args]\n  {type: \"ArrayExpression\",\n   elements: (emit-expressions env args),\n   loc: loc})\n\n(hash-map-set! emit-specials 'js/array emit-array)\n\n(defn emit-fn [env loc args]\n  (let [params (first args)\n        body (skip1 args)\n        func-env (child-env env)]\n    {type: \"ArrowFunctionExpression\",\n     id: nil,\n     params: (emit-patterns func-env params),\n     body: (emit-return-block func-env body),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'fn emit-fn)\n\n(defn emit-if [env loc args]\n  (let [test (first args)\n        if-true (second args)\n        if-false (skip2 args)]\n    {type: \"IfStatement\",\n     test: (emit-expression env test),\n     consequent: (emit-statement env if-true),\n     alternate: (if (not-nil? if-false) (emit-block env if-false)),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'if emit-if)\n\n(defn emit-for [env loc args]\n  (let [var (first (first args))\n        value (second (first args))\n        body (skip1 args)\n        for-env (child-env env)]\n    {type: \"ForOfStatement\",\n     left: (emit-pattern for-env var),\n     right: (emit-expression for-env value),\n     body: (emit-block for-env body),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'for emit-for)\n\n(defn emit-def [env loc args]\n  {type: \"VariableDeclaration\",\n   kind: \"let\",\n   declarations: (js/array {type: \"VariableDeclarator\",\n                            id: (define-variable env (first args)),\n                            init: (emit-expression env (second args)),\n                            loc: loc}),\n   loc: loc})\n\n(hash-map-set! emit-specials 'def emit-def)\n\n(defn emit-vars [env vars]\n  {type: \"VariableDeclaration\",\n   kind: \"let\",\n   declarations: (map (.from js/Array (grouped vars 2))\n                      (fn [pair]\n                        {type: \"VariableDeclarator\",\n                         id: (define-variable env (first pair)),\n                         init: (emit-expression env (second pair))})),\n   loc: (.-loc (meta vars))})\n\n(defn emit-let [env loc args]\n  (let [vars (first args)\n        body (skip1 args)\n        let-env (child-env env)]\n    {type: \"BlockStatement\",\n     body: (js/array (emit-vars let-env vars) (spread (emit-statements let-env body))),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'let emit-let)\n\n(defn emit-cond [env loc args]\n  (defn emit-branch [args]\n    (let [expr (first args),\n          rest (skip1 args),\n          test (first expr),\n          body (skip1 expr)]\n      (if (= test 'else)\n        (emit-block env body)\n        {type: \"IfStatement\",\n         test: (emit-expression env test),\n         consequent: (emit-block env body),\n         alternate: (if (not-empty? rest) (emit-branch rest))})))\n  (emit-branch args))\n\n(hash-map-set! emit-specials 'cond emit-cond)\n\n(defn emit-loop [env loc args]\n  (let [vars (first args)\n        body (skip1 args)\n        loop-env (recur-env env)]\n    (if (empty? vars)\n      {type: \"WhileStatement\",\n       test: (emit-literal loop-env true),\n       body: (emit-return-block loop-env body)}\n      {type: \"BlockStatement\",\n       body: (js/array (emit-vars loop-env vars)\n                       {type: \"WhileStatement\",\n                        test: (emit-literal loop-env true),\n                        body: (emit-return-block loop-env body)})})))\n\n(hash-map-set! emit-specials 'loop emit-loop)\n\n(defn emit-do [env loc args]\n  {type: \"BlockStatement\",\n   body: (emit-statements env args),\n   loc: loc})\n\n(hash-map-set! emit-specials 'do emit-do)\n\n(defn emit-yield [env loc args]\n  {type: \"YieldExpression\",\n   argument: (emit-expression env (first args)),\n   loc: loc})\n\n(hash-map-set! emit-specials 'yield emit-yield)\n\n(defn emit-recur [env loc args]\n  (if (!= (.-length (.-loopVariables env)) (.-length args))\n    (error (+ \"Recur with not enough args\" (.-length (.-loopVariables env)) (.-length args))))\n  (if (empty? args)\n    {type: \"ContinueStatement\",\n     loc: loc}\n    {type: \"BlockStatement\",\n     body: (js/array (spread (map (zip (.-loopVariables env) args)\n                                  (fn [pair]\n                                    {type: \"ExpressionStatement\",\n                                     expression: {type: \"AssignmentExpression\",\n                                                  operator: \"=\",\n                                                  left: (emit-pattern env (first pair)),\n                                                  right: (emit-expression env (second pair))}})))\n                    {type: \"ContinueStatement\"}),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'recur emit-recur)\n\n(defn emit-dict [env ctx args]\n  {type: \"ObjectExpression\",\n   properties: (map (.from js/Array (grouped args 2))\n                    (fn [pair]\n                      {type: \"Property\",\n                       key: (if (keyword? (first pair))\n                              (emit-literal env (kebabcase->camelcase (keyword->string (first pair))))\n                              (emit-literal env (first pair))),\n                       value: (emit-expression env (second pair))}))})\n\n(hash-map-set! emit-specials 'dict emit-dict)\n\n(defn emit-quote [env loc args]\n  (emit env (knight-quote (first args))))\n\n(defn knight-quote [form]\n  (cond\n    [(symbol? form) (list 'string->symbol (symbol->string form))]\n    [(list? form) (append (list 'js/array) (map knight-quote form))]\n    [else form]))\n\n(hash-map-set! emit-specials 'quote emit-quote)\n\n(defn emit-return [env loc args]\n  {type: \"ReturnStatement\",\n   argument: (if (not-empty? args)\n               (emit-expression env (first args))\n               nil),\n   loc: loc})\n\n(hash-map-set! emit-specials 'js/return emit-return)\n\n(defn emit-throw [env loc args]\n  {type: \"ThrowStatement\",\n   argument: (emit-expression env (first args)),\n   loc: loc})\n\n(hash-map-set! emit-specials 'js/throw emit-throw)\n\n(defn emit-new [env loc args]\n  {type: \"NewExpression\",\n   callee: (emit-expression env (first args)),\n   arguments: (emit-expressions env (skip1 args)),\n   loc: loc})\n\n(hash-map-set! emit-specials 'js/new emit-new)\n\n(defn emit-index [env ctx args]\n  (let [obj (first args)\n        index (second args)]\n    {type: \"MemberExpression\",\n     object: (emit-expression env obj),\n     property: (emit-expression env index),\n     computed: true}))\n\n(hash-map-set! emit-specials 'js/index emit-index)\n; -*- mode: Clojure -*-\n(js/require \"source-map-support/register\")\n\n(def fs (js/require \"fs\"))\n(def escodegen (js/require \"escodegen\"))\n(def terser (js/require \"terser\"))\n(def program (.-program (js/require \"commander\")))\n\n(.option program \"-o, --output <filename>\" \"Output JS filename\")\n(.option program \"-m, --map\" \"Generate source maps\")\n\n(.parse program (.-argv js/process))\n\n(let [output-filename (.-output program),\n      source-map-filename (if (.-map program) (if output-filename (+ output-filename \".map\") \"inline\")),\n      code (.readFileSync fs 0 \"utf-8\"),\n      forms (string->exprs code),\n      ast (emit-module forms),\n      output (.generate escodegen ast {sourceMap: \"stdin\", sourceMapWithCode: true, sourceContent: code}),\n      source-map (.toString (.-map output)),\n      minified (.minify terser (.-code output) {toplevel: true,\n                                                sourceMap: (if source-map-filename\n                                                             {content: source-map, url: source-map-filename})})]\n  (if (.-error minified)\n    (.error js/console (.-error minified))\n    (if output-filename\n      (do\n        (.writeFileSync fs output-filename (.-code minified))\n        (if (and source-map-filename (!= source-map-filename \"inline\"))\n          (.writeFileSync fs source-map-filename (.toString (.-map minified)))))\n      (println (.-code minified)))))\n"]}