{"version":3,"sources":["stdin"],"names":["hash-map","js/Map","hash-map-set!","map","key","value","set","list","items","string->symbol","string","not","contains-key?","interned-symbols","Symbol","hash-map-get","has","name","js/this","get","read-syntax","reader","start-pos","reader-pos","form","pos","skip-whitespace","c","peek-char","char-digit?","read-number","char-macro?","macro","reader-macros","read-char","token","read-token","string-prefix?","string-suffix?","substring","length","interned-keywords","Keyword","string->keyword","read","end-pos","not-nil?","meta","symbol-meta","meta-set!","input","line","column","take-while","char","char-whitespace?","take-until","predicate","start-index","index","input-length","offset","includes","string-contains?","js/parseFloat","js/parseInt","concat","a","b","prefix","startsWith","endsWith","expand-syntax-quote","bool?","number?","string?","keyword?","self-evaluating?","symbol?","tagged-list?","second","list?","js/Boolean","js/Number","js/String","tag","first","js/Array","isArray","array","func","error","msg","js/Error","nil?","read-unicode-char","d","fromCharCode","read-until","end-char","has-indent-error","start-line","start-indent","results","last-pos","indent","reader-indent-warning","reader-unterminated-error","append","indentWarnings","push","warning","seq","w","startIndex","find","js/console","marked-line","line-index","before-line-index","after-line-index","lines","split","before-line","after-line","caret-line","string-repeat","line-num","before-line-num","after-line-num","max-line-num-width","values","js/Math","max","string-pad-start","str","count","repeat","toString","repr","symbol->string","sep","join","string-join","js/JSON","stringify","symbol","width","filler","padStart","read-unmatched-delimiter","first-char","symbol->ident","ident","set-contains?","js-keywords","js-keyword?","kebabcase->camelcase","replace","regex","replace-special-chars","match","p1","toUpperCase","flags","js/RegExp","skip2","slice","not-empty?","skip1","child-env","env","hash-map-copy","variables","loopVariables","functions","functionNodes","define-function","resolve-var","function-nodes","loc","func-env","emit-patterns","params","emit-return-block","body","generator","compile-function","compiler-error","from","keys","forms","emit-pattern","define-variable","isLoop","source","start","emit-return-last","filter-not-nil","map-last","emit-statement","node","emit","expression?","statement->return","emit-return-statement","filter","last-func","item","emit-var","callee","args","field-access?","field-name","obj","emit-expression","emit-field","method-call?","method-name","method-args","emit-expressions","emit-methodcall","emit-specials","special?","emit-funcall","emit-list","emit-literal","statement->iife","statement->expression","type","expression","statements->return","test","consequent","alternate","nodes","empty?","map-not-nil","js/undefined","keyword->string","neg","unbox","keyword","valueOf","emit-bin-op","op","reduce","acc","arg","emit-block","single?","emit-statements","emit-vars","vars","grouped","pair","i","zip","arrays","_","knight-quote","has-more?","js/Symbol","string2","ch","escaped-char","js/Set","rest","docs","setter","emit-set-var","emit-set-field","emit-set-index","emit-setter","if-true","if-false","var","for-env","let-env","emit-cond","expr","loop-env","recur-env","ctx","js/require","fs","path","escodegen","terser","program","option","parse","js/process","argv","output-filename","output","output-dirname","dirname","source-map-filename","basename","code","readFileSync","ast","emit-module","read-many","make-string-reader","generate","source-map","minified","minify","writeFileSync","log","println"],"mappings":"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","sourcesContent":["; -*- mode: Clojure -*-\n\n(defn Symbol [name]\n  (set! (.-name js/this) name)\n  (js/return))\n\n(defn Keyword [name]\n  (set! (.-name js/this) name)\n  (js/return))\n\n(defn true? [value]\n  (js/=== value true))\n\n(defn false? [value]\n  (js/=== value false))\n\n(defn truthy? [value]\n  \"A value is considered truthy if it is not false and not nil (i.e., not falsy)\"\n  (js/and (js/!== value false) (js/!= value nil)))\n\n(defn falsy? [value]\n  \"A value is considered falsy if it is false or nil\"\n  (js/or (js/=== value false) (js/== value nil)))\n\n(defn not [value]\n  (js/or (js/=== value false) (js/== value nil)))\n\n(defn nil? [value]\n  (js/== value nil))\n\n(defn not-nil? [value]\n  (js/!= value nil))\n\n(defn symbol? [value]\n  (js/instanceof value Symbol))\n\n(defn keyword? [value]\n  (js/instanceof value Keyword))\n\n(defn bool? [value]\n  (js/or (js/=== (js/typeof value) \"boolean\")\n         (js/instanceof value js/Boolean)))\n\n(defn number? [value]\n  (js/or (js/=== (js/typeof value) \"number\")\n         (js/instanceof value js/Number)))\n\n(defn positive? [value]\n  (and (number? value)\n       (> value 0)))\n\n(defn negative? [value]\n  (and (number? value)\n       (< value 0)))\n\n(defn neg [value]\n  (* -1 value))\n\n(defn char? [value]\n  (js/and (js/or (js/=== (js/typeof value) \"string\")\n                 (js/instanceof value js/String))\n          (js/=== (.-length value) 1)))\n\n(defn string? [value]\n  (js/or (js/=== (js/typeof value) \"string\")\n         (js/instanceof value js/String)))\n\n(defn list? [value]\n  (.isArray js/Array value))\n\n(defn empty? [value]\n  (js/=== (.-length value) 0))\n\n(defn single? [list]\n  (and (list? list)\n       (= (.-length list) 1)))\n\n(defn not-empty? [value]\n  (and (not-nil? value)\n       (> (.-length value) 0)))\n\n(defn list [&items]\n  (js/array &items))\n\n(defn map [array func]\n  (.map array func))\n\n(defn map-not-nil [seq func]\n  (filter-not-nil (map seq func)))\n\n(defn map-last [array func last-func]\n  (.map array\n        (fn [item index]\n          (if (= index (- (.-length array) 1))\n            (last-func item)\n            (if (nil? func)\n              item\n              (func item))))))\n\n(defn find-first [seq predicate]\n  (.find seq predicate))\n\n(defn filter [seq predicate]\n  (.filter seq predicate))\n\n(defn filter-not-nil [seq]\n  (filter seq (fn [value] (not-nil? value))))\n\n\n(defn append [list &items]\n  (js/array &list &items))\n\n(defn concat [a b]\n  (+ a b))\n\n(defn string-contains? [string substring]\n  (.includes string substring))\n\n(defn string-prefix? [string prefix]\n  (.startsWith string prefix))\n\n(defn string-suffix? [string prefix]\n  (.endsWith string prefix))\n\n(defn string-join [string sep]\n  (.join string sep))\n\n; (defn parse-float [string]\n;   (js/parseFloat string))\n\n; (defn parse-int [string]\n;   (js/parseInt string))\n\n(defn println [&args]\n  (.log js/console &(map args string)))\n\n(defn print [&args]\n  (for [arg args]\n    (.write (.-stdout js/process) (string arg))))\n\n(defn hash-map []\n  (js/new js/Map))\n\n(defn hash-map-get [map key]\n  (.get map key))\n\n(defn hash-map-set! [map key value]\n  (.set map key value))\n\n(defn hash-map-copy [map]\n  (js/new js/Map map))\n\n(defn array-copy [array]\n  (.from js/Array array))\n\n(defn contains-key? [map key]\n  (.has map key))\n\n(def interned-symbols (hash-map))\n(def interned-keywords (hash-map))\n\n(defn string->symbol [string]\n  (if (not (contains-key? interned-symbols string))\n    (hash-map-set! interned-symbols string (js/new Symbol string)))\n  (hash-map-get interned-symbols string))\n\n(defn symbol->string [symbol]\n  (.-name symbol))\n\n(defn keyword->string [keyword]\n  (.-name keyword))\n\n(defn string->keyword [string]\n  (let [substring (if (string-prefix? string \":\")\n                    (.substring string 1)\n                    (if (string-suffix? string \":\")\n                      (.substring string 0 (- (.-length string) 1))\n                      string))]\n    (if (not (contains-key? interned-keywords substring))\n      (hash-map-set! interned-keywords substring (js/new Keyword substring)))\n    (hash-map-get interned-keywords substring)))\n\n(defn first [list]\n  (js/index list 0))\n\n(defn second [list]\n  (js/index list 1))\n\n(defn third [list]\n  (js/index list 2))\n\n(defn fourth [list]\n  (js/index list 3))\n\n(defn skip1 [list]\n  (.slice list 1))\n\n(defn skip2 [list]\n  (.slice list 2))\n\n(defn split-last [seq]\n  (js/array (.slice seq 0 (- (.-length seq) 1))\n            (js/index seq (- (.-length seq) 1))))\n\n(defn regex [str flags]\n  (js/new js/RegExp str flags))\n\n(defn error [msg]\n  (js/throw (js/new js/Error msg)))\n\n(defn tagged-list? [value tag]\n  (and (list? value)\n       (= (first value) tag)))\n\n(defn repr [value]\n  (cond\n    [(nil? value) \"nil\"]\n    [(symbol? value) (symbol->string value)]\n    [(list? value) (+ \"(\" (string-join (map value repr) \" \") \")\")]\n    [else (.stringify js/JSON value)]))\n\n(defgen grouped [seq count]\n  (loop [i 0]\n    (if (< i (.-length seq))\n      (do\n        (yield (.slice seq i (+ i count)))\n        (recur (+ i count))))))\n\n(defn zip [&arrays]\n  (map (first arrays)\n       (fn [_ index]\n         (map arrays (fn [array] (js/index array index))))))\n\n(defn set [&values]\n  (js/new js/Set values))\n\n(defn set-contains? [set value]\n  (.has set value))\n\n(defn box [value]\n  (cond\n    [(bool? value) (js/new js/Boolean value)]\n    [(number? value) (js/new js/Number value)]\n    [(string? value) (js/new js/String value)]\n    [else value]))\n\n(defn unbox [value]\n  (if (not-nil? value)\n    (.valueOf value)\n    nil))\n\n(def symbol-meta (js/Symbol \"meta\"))\n\n(defn meta [value]\n  (js/index value symbol-meta))\n\n(defn meta-set! [value meta]\n  (set! (js/index value symbol-meta) meta)\n  (js/return))\n\n(defn string-repeat [str count]\n  (.repeat str count))\n\n(defn string-pad-start [string width filler]\n  (.padStart string width filler))\n\n(defn string-pad-end [string width filler]\n  (.padEnd string width filler))\n\n(defn string [value]\n  (cond\n    [(nil? value) \"nil\"]\n    [(string? value) value]\n    [(number? value) (.toString value)]\n    [(bool? value) (.toString value)]\n    [else (repr value)]))\n\n(defn max [&values]\n  (.max js/Math &values))\n; -*- mode: Clojure -*-\n\n(defn self-evaluating? [form]\n  (or (bool? form) (number? form) (string? form) (keyword? form)))\n\n(defn expand-syntax-quote [form]\n  (cond\n    [(self-evaluating? form) form]\n    [(symbol? form) (list 'quote form)]\n    [(tagged-list? form 'unquote) (second form)]\n    [(list? form) (list 'list &(map form expand-syntax-quote))]\n    [else (list 'quote form)]))\n\n(defn make-string-reader [string]\n  {input: string,\n   index: 0,\n   line: 1,\n   column: 0,\n   indent-warnings: (js/array)})\n\n(def reader-macros (hash-map))\n\n(defn reader-pos [reader]\n  {line: (.-line reader),\n   column: (.-column reader)})\n\n(defn reader-indent-warning [reader start-index end-char pos]\n  (.push (.-indentWarnings reader) {start-index: start-index, end-char: end-char, pos: pos}))\n\n(defn reader-unterminated-error [reader start-index start-pos end-char]\n  (let [warning (find-first (.-indentWarnings reader) (fn [w] (>= (.-startIndex w) start-index)))]\n    (.error js/console warning)\n    (error (+ \"Unexpected EOF, expected: '\" end-char \"'\\n\\n\"\n              \"Started here:\\n\"\n              (marked-line (.-input reader) start-pos) \"\\n\\n\"\n              \"Based on indent:\\n\"\n              (marked-line (.-input reader) (.-pos warning))))))\n\n(defn read-char [reader]\n  (let [char (js/index (.-input reader) (.-index reader))]\n    (set! (.-index reader) (+ (.-index reader) 1))\n    (if (= char \\newline)\n      (do\n        (set! (.-line reader) (+ (.-line reader) 1))\n        (set! (.-column reader) 0))\n      (set! (.-column reader) (+ (.-column reader) 1)))\n    char))\n\n(defn peek-char [reader offset]\n  (js/index (.-input reader)\n            (if (not-nil? offset)\n                (+ (.-index reader) offset)\n                (.-index reader))))\n\n(defn has-more? [reader]\n  (< (.-index reader) (.-length (.-input reader))))\n\n(defn char-whitespace? [char]\n  (or (= char \\space)\n      (= char \\tab)\n      (= char \\newline)\n      (= char \\,)))\n\n(defn char-digit? [char]\n  (and (>= char \\0)\n       (<= char \\9)))\n\n(defn char-macro? [char]\n  (contains-key? reader-macros char))\n\n(defn take-until [reader predicate]\n  (let [start-index (.-index reader)\n        input-length (.-length (.-input reader))]\n    (loop [index (.-index reader),\n           line (.-line reader),\n           column (.-column reader)]\n      (let [char (js/index (.-input reader) index)]\n        (if (or (>= index input-length)\n                (predicate char))\n          (do\n            (set! (.-index reader) index)\n            (set! (.-line reader) line)\n            (set! (.-column reader) column)\n            (.substring (.-input reader) start-index index))\n          (if (= char \\newline)\n            (recur (+ index 1) (+ line 1) 0)\n            (recur (+ index 1) line (+ column 1))))))))\n\n(defn take-while [reader predicate]\n  (take-until reader (fn [char] (not (predicate char)))))\n\n(defn skip-whitespace [reader]\n  (loop []\n    (take-while reader (fn [char] (char-whitespace? char)))\n    (if (= (peek-char reader) \\;)\n      (do\n        (take-until reader (fn [c] (= c \\newline)))\n        (recur)))))\n\n(defn read-token [reader]\n  (concat (read-char reader)\n          (take-until reader (fn (c) (or (char-whitespace? c) (char-macro? c))))))\n\n(defn parse-token [token]\n  (cond\n    [(= token \"nil\") nil]\n    [(= token \"true\") true]\n    [(= token \"false\") false]\n    [(or (string-prefix? token \":\")\n         (string-suffix? token \":\")) (string->keyword token)]\n    [else (string->symbol token)]))\n\n(defn read-number [reader]\n  (let [string (read-token reader)]\n    (if (string-contains? string \".\")\n      (js/parseFloat string)\n      (js/parseInt string))))\n\n(defn read-character [reader]\n  (let [char (read-token reader)]\n    (cond\n      [(= char \"newline\") \\newline]\n      [(= char \"return\") \\return]\n      [(= char \"tab\") \\tab]\n      [(= char \"space\") \\space]\n      [(= (.-length char) 1) char]\n      [else (error (+ \"Unrecognized char: '\" char \"'\"))])))\n\n(defn read-quote [reader first-char pos]\n  (list 'quote (read-syntax reader)))\n\n(defn read-syntax-quote [reader first-char pos]\n  (expand-syntax-quote (read-syntax reader)))\n\n(defn read-spread [reader first-char pos]\n  (list 'spread (read-syntax reader)))\n\n(defn read-unquote [reader first-char pos]\n  (list 'unquote (read-syntax reader)))\n\n(defn read-list [reader first-char pos]\n  (read-until reader \\) pos))\n\n(defn read-array [reader first-char pos]\n  (read-until reader \\] pos))\n\n(defn read-struct [reader first-char pos]\n  (list 'dict &(read-until reader \\} pos)))\n\n(defn read-unmatched-delimiter [reader first-char]\n  (error (concat \"Unmatched delimiter: \" first-char)))\n\n(defn read-string [reader first-char pos]\n  (loop [string \"\"]\n    (let [part (take-until reader (fn [ch] (or (= ch \\\")\n                                               (= ch \\\\))))\n          string2 (concat string part)\n          char (read-char reader)]\n      (cond\n        [(nil? char) (error \"Unexpected EOF while reading string\")]\n        [(= char \\\") string2]\n        [(= char \\\\)\n         (let [char (read-char reader)\n               escaped-char (cond\n                              [(nil? char) (error \"Unexpected EOF while reading character escape\")]\n                              [(= char \\\") char]\n                              [(= char \\\\) char]\n                              [(= char \\/) char]\n                              [(= char \\n) \\newline]\n                              [(= char \\t) \\tab]\n                              [(= char \\r) \\return]\n                              [(= char \\u) (read-unicode-char reader)]\n                              [else (concat (error \"Unrecognized character escape\" char))])]\n           (recur (concat string2 escaped-char)))]))))\n\n(defn read-unicode-char [reader]\n  (let [a (read-char reader),\n        b (read-char reader),\n        c (read-char reader),\n        d (read-char reader)]\n    (.fromCharCode js/String (js/parseInt (+ a b c d)))))\n\n(defn marked-line [input pos]\n  (let [line-index (- (.-line pos) 1),\n        before-line-index (- line-index 1),\n        after-line-index (+ line-index 1),\n        lines (.split input \\newline),\n        line (js/index lines line-index),\n        before-line (or (js/index lines before-line-index) \"\"),\n        after-line (or (js/index lines after-line-index) \"\"),\n        col (.-column pos),\n        caret-line (concat (string-repeat \" \" col) \"^\"),\n        line-num (string (+ line-index 1)),\n        before-line-num (string (+ before-line-index 1)),\n        after-line-num (string (+ after-line-index 1)),\n        max-line-num-width (max (.-length line-num)\n                                (.-length before-line-num)\n                                (.-length after-line-num))]\n    (+ (string-pad-start before-line-num max-line-num-width) \" \" before-line \"\\n\"\n       (string-pad-start line-num max-line-num-width) \" \" line \"\\n\"\n       (string-repeat \" \" max-line-num-width) \" \" caret-line \"\\n\"\n       (string-pad-start after-line-num max-line-num-width) \" \" after-line)))\n\n(defn reader-error [reader pos msg]\n  (error (+ msg \"\\n\\n\" (marked-line (.-input reader) pos))))\n\n(defn read-until [reader end-char start-pos]\n  (let [has-indent-error false,\n        start-index (- (.-index reader) 1),\n        start-line (.-line start-pos),\n        start-indent (.-column start-pos)]\n    (loop [results (list)]\n      (if (not has-indent-error)\n        (let [last-pos (reader-pos reader)]\n          (skip-whitespace reader)\n          (let [pos (reader-pos reader),\n                line (.-line pos),\n                indent (.-column pos)]\n            (if (and (> line start-line) (<= indent start-indent))\n              (do\n                (set! has-indent-error true)\n                (reader-indent-warning reader start-index end-char last-pos))))))\n      (let [char (peek-char reader)]\n        (cond\n          [(nil? char)\n           (reader-unterminated-error reader start-index start-pos end-char)]\n          [(= char end-char)\n           (read-char reader)\n           results]\n          [else (recur (append results (read-syntax reader)))])))))\n\n(defn read [reader pos]\n  (skip-whitespace reader)\n  (let [c (peek-char reader)]\n    (cond\n      [(char-digit? c) (read-number reader)]\n      [(char-macro? c)\n       (let [macro (hash-map-get reader-macros c)]\n         (read-char reader)\n         (macro reader c pos))]\n      [(and (or (= c \\+) (= c \\-))\n            (char-digit? (peek-char reader 1)))\n       (read-number reader)]\n      [else (parse-token (read-token reader))])))\n\n(defn read-syntax [reader]\n  (let [start-pos (reader-pos reader),\n        form (read reader start-pos),\n        end-pos (reader-pos reader)]\n    (if (not-nil? form)\n      (meta-set! form {loc: {source: (.-input reader),\n                             start: start-pos,\n                             end: end-pos}}))\n    form))\n\n(defn read-many [reader]\n  (loop [results (list)]\n    (skip-whitespace reader)\n    (if (has-more? reader)\n      (recur (append results (read-syntax reader)))\n      results)))\n\n(defn string->expr [str]\n  (read-syntax (make-string-reader str)))\n\n(defn string->exprs [str]\n  (read-many (make-string-reader str)))\n\n(hash-map-set! reader-macros \\' read-quote)\n(hash-map-set! reader-macros \\` read-syntax-quote)\n(hash-map-set! reader-macros \\& read-spread)\n(hash-map-set! reader-macros \\~ read-unquote)\n(hash-map-set! reader-macros \\\\ read-character)\n(hash-map-set! reader-macros \\\" read-string)\n(hash-map-set! reader-macros \\( read-list)\n(hash-map-set! reader-macros \\) read-unmatched-delimiter)\n(hash-map-set! reader-macros \\[ read-array)\n(hash-map-set! reader-macros \\] read-unmatched-delimiter)\n(hash-map-set! reader-macros \\{ read-struct)\n(hash-map-set! reader-macros \\} read-unmatched-delimiter)\n; -*- mode: Clojure -*-\n\n(def js-keywords (set \"var\" \"let\" \"const\"))\n\n(defn compiler-error [form msg]\n  (if (and (meta form) (.-loc (meta form)))\n    (let [loc (.-loc (meta form)),\n          source (.-source loc),\n          pos (.-start loc)]\n      (error (+ msg \"\\n\\n\" (marked-line source pos))))\n    (error msg)))\n\n(defn make-env []\n  {functions: (hash-map),\n   function-nodes: (hash-map),\n   variables: (hash-map),\n   is-loop: false})\n\n(defn child-env [env]\n  {variables: (hash-map-copy (.-variables env))\n   loop-variables: (.-loopVariables env),\n   functions: (.-functions env),\n   function-nodes: (.-functionNodes env),\n   is-loop: false})\n\n(defn recur-env [env]\n  {variables: (hash-map-copy (.-variables env))\n   loop-variables: (js/array),\n   functions: (.-functions env),\n   function-nodes: (.-functionNodes env),\n   is-loop: true})\n\n(defn replace-special-chars [ident]\n  (.replace (.replace (.replace (.replace ident \"!\" \"\")\n                                \"->\" \"-to-\")\n                      (regex \"^((contains|has).*)\\\\?$\") \"$1\")\n            (regex \"^(.*)\\\\?$\") \"is-$1\"))\n\n(defn kebabcase->camelcase [ident]\n  (.replace (replace-special-chars ident)\n            (regex \"[-_]([a-zA-Z])\" \"g\")\n            (fn [match p1] (.toUpperCase p1))))\n\n(defn sanitize-js-keywords [ident]\n  (if (js-keyword? ident)\n    (concat ident \"$\")\n    ident))\n\n(defn symbol->ident [symbol]\n  (cond\n    [(= symbol 'Symbol) \"LispSymbol\"]\n    [else (sanitize-js-keywords (kebabcase->camelcase (symbol->string symbol)))]))\n\n(defn define-variable [env symbol]\n  (let [variables (.-variables env)]\n    (if (not (contains-key? variables symbol))\n      (hash-map-set! variables symbol (symbol->ident symbol)))\n    (if (.-isLoop env)\n      (.push (.-loopVariables env) symbol))\n    (resolve-var env symbol)))\n\n(defn define-function [env name func]\n  (let [functions (.-functions env)]\n    (if (contains-key? functions name)\n      (error (+ \"Function already defined: \" (symbol->string name)))\n      (hash-map-set! functions name func))\n    nil))\n\n(defn resolve-var [env symbol]\n  (let [variables (.-variables env),\n        functions (.-functions env),\n        function-nodes (.-functionNodes env),\n        string (symbol->string symbol),\n        loc (if (meta symbol) (.-loc (meta symbol)))]\n    (cond\n      [(string-prefix? string \"js/\")\n       {type: \"Identifier\",\n        name: (.substring string 3),\n        originalName: string,\n        loc: loc}]\n      [(contains-key? variables symbol)\n       {type: \"Identifier\",\n        name: (hash-map-get variables symbol),\n        originalName: string,\n        loc: loc}]\n      [(contains-key? functions symbol)\n       (if (not (contains-key? function-nodes symbol))\n         (compile-function env (hash-map-get functions symbol)))\n       {type: \"Identifier\",\n        name: (.-ident (hash-map-get functions symbol)),\n        originalName: string,\n        loc: loc}]\n      [else\n       (compiler-error symbol (+ \"Variable or function not found: \" string \" - \"\n                                 (map (.from js/Array (.keys variables)) symbol->string) \" - \"\n                                 (map (.from js/Array (.keys functions)) symbol->string)))])))\n\n(defn compile-function [env func]\n  (let [func-env (child-env env)]\n    (hash-map-set! (.-functionNodes env)\n                   (.-name func) 'placeholder)\n    (hash-map-set! (.-functionNodes env)\n                   (.-name func)\n                   {type: \"FunctionDeclaration\",\n                    id: {type: \"Identifier\",\n                         name: (.-ident func),\n                         originalName: (symbol->string (.-name func)),\n                         loc: (.-loc (meta (.-name func)))},\n                    params: (emit-patterns func-env (.-params func)),\n                    body: (emit-return-block func-env (.-body func)),\n                    generator: (.-generator func),\n                    loc: (.-loc func)})))\n; -*- mode: Clojure -*-\n\n(def emit-specials (hash-map))\n\n;; Predicates\n\n(defn field-access? [form]\n  (and (symbol? form)\n       (string-prefix? (symbol->string form) \".-\")))\n\n(defn method-call? [form]\n  (and (symbol? form)\n       (string-prefix? (symbol->string form) \".\")))\n\n(defn special? [form]\n  (and (symbol? form)\n       (contains-key? emit-specials form)))\n\n(defn js-keyword? [ident]\n  (set-contains? js-keywords ident))\n\n(defn expression? [node]\n  (let [type (.-type node)]\n    (or (= type \"Literal\")\n        (= type \"Identifier\")\n        (string-suffix? type \"Expression\")\n        (string-suffix? type \"Element\"))))\n\n;; AST Transformation\n\n(defn statement->iife [node]\n  {type: \"CallExpression\",\n   callee: {type: \"ArrowFunctionExpression\",\n            id: nil,\n            params: (js/array),\n            body: {type: \"BlockStatement\",\n                   body: (js/array (statement->return node)),\n                   loc: (.-loc node)}},\n   arguments: (js/array)})\n\n(defn statement->expression [node]\n  (statement->iife node))\n\n(defn statements->return [nodes]\n  (if (empty? nodes)\n    (js/array {:type \"ReturnStatement\",\n               :argument nil})\n    (map-last nodes nil statement->return)))\n\n(defn statement->return [node]\n  (let [type (.-type node)]\n    (cond\n      [(= type \"ReturnStatement\") node]\n      [(= type \"ForOfStatement\") node]\n      [(= type \"ContinueStatement\") node]\n      [(= type \"ThrowStatement\") node]\n      [(= type \"ExpressionStatement\")\n       {type: \"ReturnStatement\",\n        argument: (.-expression node),\n        loc: (.-loc node)}]\n      [(= type \"BlockStatement\")\n       {type: \"BlockStatement\",\n        body: (statements->return (.-body node)),\n        loc: (.-loc node)}]\n      [(= type \"WhileStatement\")\n       {type: \"WhileStatement\",\n        test: (.-test node),\n        body: (statement->return (.-body node)),\n        loc: (.-loc node)}]\n      [(= type \"IfStatement\")\n       {type: \"IfStatement\",\n        test: (.-test node),\n        consequent: (statement->return (.-consequent node)),\n        alternate: (if (.-alternate node)\n                       (statement->return (.-alternate node))\n                       nil),\n        loc: (.-loc node)}]\n      [else (error (concat \"Unsupported return statement: \" type))])))\n\n;; AST Generation of specific types\n\n(defn emit-return-last [env forms]\n  (filter-not-nil (map-last forms (fn [form] (emit-statement env form))\n                                  (fn [form] (emit-return-statement env form)))))\n\n(defn emit-return-block [env forms]\n  {type: \"BlockStatement\",\n   body: (emit-return-last env forms)})\n\n(defn emit-return-statement [env form]\n  (let [node (emit env form)]\n    (if (expression? node)\n      {type: \"ReturnStatement\",\n       argument: node,\n       loc: (.-loc node)}\n      (statement->return node))))\n\n(defn emit-statements [env forms]\n  (map-not-nil forms (fn [form] (emit-statement env form))))\n\n(defn emit-statement [env form]\n  (let [node (emit env form)]\n    (cond\n      [(nil? node) node]\n      [(expression? node)\n       {type: \"ExpressionStatement\",\n        expression: node,\n        loc: (.-loc node)}]\n      [else node])))\n\n(defn emit-expressions [env forms]\n  (map-not-nil forms (fn [form] (emit-expression env form))))\n\n(defn emit-expression [env form]\n  (let [node (emit env form)]\n    (cond\n      [(nil? node) node]\n      [(expression? node) node]\n      [else (statement->expression node)])))\n\n(defn emit-patterns [env forms]\n  (map forms (fn [form] (emit-pattern env form))))\n\n(defn emit-pattern [env form]\n  (cond\n    [(symbol? form)\n     (define-variable env form)]\n    [(tagged-list? form 'spread)\n     {type: \"RestElement\",\n      argument: (define-variable env (second form)),\n      loc: (.-loc (meta form))}]\n    [(list? form)\n     {type: \"ArrayPattern\",\n      elements: (emit-patterns env form)}]\n    [else (compiler-error form \"Unrecognized pattern\")]))\n\n(defn emit-block [env forms]\n  (if (single? forms)\n    (emit-statement env (first forms))\n    {type: \"BlockStatement\",\n     body: (emit-statements env forms)}))\n\n;; AST Generation\n\n(defn emit-module [forms]\n  (let [env (make-env),\n        nodes (emit-statements env forms),\n        function-nodes (.-functionNodes env)]\n    {type: \"Program\",\n     body: (js/array &(.values function-nodes) &nodes)}))\n\n(defn emit [env form]\n  (cond\n    [(symbol? form) (emit-var env form)]\n    [(list? form) (emit-list env form)]\n    [else (emit-literal env form)]))\n\n(defn emit-literal [env form]\n  (cond\n    [(js/=== form js/undefined) (error \"Undefined!\")]\n    [(keyword? form) (emit env (list 'string->keyword (keyword->string form)))]\n    [(negative? form)\n     {type: \"UnaryExpression\",\n      operator: \"-\",\n      prefix: true,\n      argument: {type: \"Literal\",\n                 value: (neg (unbox form))},\n      loc: (if (and (not-nil? form) (meta form)) (.-loc (meta form)))}]\n    [else {type: \"Literal\",\n           value: (unbox form),\n           loc: (if (and (not-nil? form) (meta form)) (.-loc (meta form)))}]))\n\n(defn emit-var [env symbol]\n  (resolve-var env symbol))\n\n(defn emit-list [env form]\n  (let [loc (if (meta form) (.-loc (meta form))),\n        callee (first form),\n        args (skip1 form)]\n    (cond\n      [(field-access? callee) (emit-field env loc callee args)]\n      [(method-call? callee) (emit-methodcall env loc callee args)]\n      [(special? callee) ((hash-map-get emit-specials callee) env loc args)]\n      [else (emit-funcall env loc callee args)])))\n\n(defn emit-field [env loc callee args]\n  (let [field-name (.substring (symbol->string callee) 2)\n        obj (first args)]\n    {type: \"MemberExpression\",\n     object: (emit-expression env obj),\n     property: {type: \"Identifier\",\n                name: field-name,\n                loc: (.-loc (meta callee))},\n     computed: false,\n     loc: loc}))\n\n(defn emit-methodcall [env loc callee args]\n  (let [method-name (.substring (symbol->string callee) 1)\n        obj (first args)\n        method-args (skip1 args)]\n    {type: \"CallExpression\",\n     callee: {type: \"MemberExpression\",\n              object: (emit-expression env obj),\n              property: {type: \"Identifier\",\n                         name: method-name,\n                         loc: (.-loc (meta callee))},\n              computed: false},\n     arguments: (emit-expressions env method-args),\n     loc: loc}))\n\n(defn emit-funcall [env loc callee args]\n  {type: \"CallExpression\",\n   callee: (emit-expression env callee),\n   arguments: (emit-expressions env args),\n   loc: loc})\n\n(defn emit-defn [env loc args]\n  (let [name (first args)\n        ident (symbol->ident name)\n        params (second args)\n        rest (skip2 args)\n        docs (if (and (string? (first rest))\n                      (not-empty? (skip1 rest)))\n                 (first rest))\n        body (if docs (skip1 rest) rest)\n        func-env (child-env env)]\n    (define-function env name {name: name,\n                               ident: ident,\n                               params: params,\n                               docs: docs,\n                               body: body,\n                               loc: loc,\n                               generator: false})))\n\n(hash-map-set! emit-specials 'defn emit-defn)\n\n(defn emit-defgen [env loc args]\n  (let [name (first args)\n        ident (symbol->ident name)\n        params (second args)\n        rest (skip2 args)\n        docs (if (and (string? (first rest))\n                      (not-empty? (skip1 rest)))\n                 (first rest))\n        body (if docs (skip1 rest) rest)\n        func-env (child-env env)]\n    (define-function env name {name: name,\n                               ident: ident,\n                               params: params,\n                               docs: docs,\n                               body: body,\n                               loc: loc,\n                               generator: true})))\n\n(hash-map-set! emit-specials 'defgen emit-defgen)\n\n(defn emit-set [env loc args]\n  (let [setter (first args)\n        value (second args)]\n    (cond\n      [(symbol? setter) (emit-set-var env loc setter value)]\n      [(list? setter) (emit-setter env loc setter value)]\n      [else (error (concat \"Invalid setter: \" (repr setter)))])))\n\n(defn emit-setter [env loc setter value]\n  (let [callee (first setter)\n        args (skip1 setter)]\n    (cond\n      [(field-access? callee) (emit-set-field env loc callee args value)]\n      [(= callee 'js/index) (emit-set-index env loc args value)]\n      [else (error (concat \"Invalid setter: \" (repr setter)))])))\n\n(defn emit-set-var [env loc symbol value]\n  {type: \"AssignmentExpression\",\n   operator: \"=\",\n   left: (resolve-var env symbol),\n   right: (emit-expression env value),\n   loc: loc})\n\n(defn emit-set-field [env loc symbol args value]\n  (let [field-name (.substring (symbol->string symbol) 2)\n        obj (first args)]\n    {type: \"AssignmentExpression\",\n     operator: \"=\",\n     left: {type: \"MemberExpression\",\n            object: (emit-expression env obj),\n            property: {type: \"Identifier\",\n                       name: field-name,\n                       loc: (.-loc (meta symbol))},\n            computed: false},\n     right: (emit-expression env value),\n     loc: loc}))\n\n(defn emit-set-index [env loc args value]\n  (let [obj (first args)\n        index (second args)]\n    {type: \"AssignmentExpression\",\n     operator: \"=\",\n     left: {type: \"MemberExpression\",\n            object: (emit-expression env obj),\n            property: (emit-expression env index),\n            computed: true},\n     right: (emit-expression env value),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'set! emit-set)\n\n(defn emit-bin-op [op]\n  (fn [env loc args]\n    (if (empty? args)\n      (error \"Empty operator expression\"))\n    (.reduce (emit-expressions env args)\n            (fn [acc, arg]\n              {type: \"BinaryExpression\",\n               operator: op,\n               left: acc,\n               right: arg,\n               loc: loc}))))\n\n(hash-map-set! emit-specials 'and (emit-bin-op \"&&\"))\n(hash-map-set! emit-specials 'or (emit-bin-op \"||\"))\n(hash-map-set! emit-specials 'js/and (emit-bin-op \"&&\"))\n(hash-map-set! emit-specials 'js/or (emit-bin-op \"||\"))\n(hash-map-set! emit-specials 'js/=== (emit-bin-op \"===\"))\n(hash-map-set! emit-specials 'js/!== (emit-bin-op \"!==\"))\n(hash-map-set! emit-specials 'js/== (emit-bin-op \"==\"))\n(hash-map-set! emit-specials 'js/!= (emit-bin-op \"!=\"))\n(hash-map-set! emit-specials '= (emit-bin-op \"===\"))\n(hash-map-set! emit-specials '!= (emit-bin-op \"!==\"))\n(hash-map-set! emit-specials '>= (emit-bin-op \">=\"))\n(hash-map-set! emit-specials '<= (emit-bin-op \"<=\"))\n(hash-map-set! emit-specials '> (emit-bin-op \">\"))\n(hash-map-set! emit-specials '< (emit-bin-op \"<\"))\n(hash-map-set! emit-specials '+ (emit-bin-op \"+\"))\n(hash-map-set! emit-specials '- (emit-bin-op \"-\"))\n(hash-map-set! emit-specials '* (emit-bin-op \"*\"))\n(hash-map-set! emit-specials '/ (emit-bin-op \"/\"))\n(hash-map-set! emit-specials 'mod (emit-bin-op \"%\"))\n(hash-map-set! emit-specials 'js/instanceof (emit-bin-op \"instanceof\"))\n\n(defn emit-spread [env loc args]\n  {type: \"SpreadElement\",\n   argument: (emit-expression env (first args)),\n   loc: loc})\n\n(hash-map-set! emit-specials 'spread emit-spread)\n\n(defn emit-array [env loc args]\n  {type: \"ArrayExpression\",\n   elements: (emit-expressions env args),\n   loc: loc})\n\n(hash-map-set! emit-specials 'js/array emit-array)\n\n(defn emit-fn [env loc args]\n  (let [params (first args)\n        body (skip1 args)\n        func-env (child-env env)]\n    {type: \"ArrowFunctionExpression\",\n     id: nil,\n     params: (emit-patterns func-env params),\n     body: (emit-return-block func-env body),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'fn emit-fn)\n\n(defn emit-if [env loc args]\n  (let [test (first args)\n        if-true (second args)\n        if-false (skip2 args)]\n    {type: \"IfStatement\",\n     test: (emit-expression env test),\n     consequent: (emit-statement env if-true),\n     alternate: (if (not-nil? if-false) (emit-block env if-false)),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'if emit-if)\n\n(defn emit-for [env loc args]\n  (let [var (first (first args))\n        value (second (first args))\n        body (skip1 args)\n        for-env (child-env env)]\n    {type: \"ForOfStatement\",\n     left: (emit-pattern for-env var),\n     right: (emit-expression for-env value),\n     body: (emit-block for-env body),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'for emit-for)\n\n(defn emit-def [env loc args]\n  {type: \"VariableDeclaration\",\n   kind: \"let\",\n   declarations: (js/array {type: \"VariableDeclarator\",\n                            id: (define-variable env (first args)),\n                            init: (emit-expression env (second args)),\n                            loc: loc}),\n   loc: loc})\n\n(hash-map-set! emit-specials 'def emit-def)\n\n(defn emit-vars [env vars]\n  {type: \"VariableDeclaration\",\n   kind: \"let\",\n   declarations: (map (.from js/Array (grouped vars 2))\n                      (fn [pair]\n                        {type: \"VariableDeclarator\",\n                         id: (define-variable env (first pair)),\n                         init: (emit-expression env (second pair))})),\n   loc: (.-loc (meta vars))})\n\n(defn emit-let [env loc args]\n  (let [vars (first args)\n        body (skip1 args)\n        let-env (child-env env)]\n    {type: \"BlockStatement\",\n     body: (js/array (emit-vars let-env vars) &(emit-statements let-env body)),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'let emit-let)\n\n(defn emit-cond [env loc args]\n  (let [expr (first args),\n        rest (skip1 args),\n        test (first expr),\n        body (skip1 expr)]\n    (if (= test 'else)\n      (emit-block env body)\n      {type: \"IfStatement\",\n       test: (emit-expression env test),\n       consequent: (emit-block env body),\n       alternate: (if (not-empty? rest) (emit-cond env loc rest))})))\n\n(hash-map-set! emit-specials 'cond emit-cond)\n\n(defn emit-loop [env loc args]\n  (let [vars (first args)\n        body (skip1 args)\n        loop-env (recur-env env)]\n    (if (empty? vars)\n      {type: \"WhileStatement\",\n       test: (emit-literal loop-env true),\n       body: (emit-return-block loop-env body)}\n      {type: \"BlockStatement\",\n       body: (js/array (emit-vars loop-env vars)\n                       {type: \"WhileStatement\",\n                        test: (emit-literal loop-env true),\n                        body: (emit-return-block loop-env body)})})))\n\n(hash-map-set! emit-specials 'loop emit-loop)\n\n(defn emit-do [env loc args]\n  {type: \"BlockStatement\",\n   body: (emit-statements env args),\n   loc: loc})\n\n(hash-map-set! emit-specials 'do emit-do)\n\n(defn emit-yield [env loc args]\n  {type: \"YieldExpression\",\n   argument: (emit-expression env (first args)),\n   loc: loc})\n\n(hash-map-set! emit-specials 'yield emit-yield)\n\n(defn emit-recur [env loc args]\n  (if (!= (.-length (.-loopVariables env)) (.-length args))\n    (error (+ \"Recur with not enough args\" (.-length (.-loopVariables env)) (.-length args))))\n  (if (empty? args)\n    {type: \"ContinueStatement\",\n     loc: loc}\n    {type: \"BlockStatement\",\n     body: (js/array &(map (zip (.-loopVariables env) args)\n                           (fn [pair]\n                             {type: \"ExpressionStatement\",\n                              expression: {type: \"AssignmentExpression\",\n                                           operator: \"=\",\n                                           left: (emit-pattern env (first pair)),\n                                           right: (emit-expression env (second pair))}}))\n                    {type: \"ContinueStatement\"}),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'recur emit-recur)\n\n(defn emit-dict [env ctx args]\n  {type: \"ObjectExpression\",\n   properties: (map (.from js/Array (grouped args 2))\n                    (fn [pair]\n                      {type: \"Property\",\n                       key: (if (keyword? (first pair))\n                              (emit-literal env (kebabcase->camelcase (keyword->string (first pair))))\n                              (emit-literal env (first pair))),\n                       value: (emit-expression env (second pair))}))})\n\n(hash-map-set! emit-specials 'dict emit-dict)\n\n(defn emit-quote [env loc args]\n  (emit env (knight-quote (first args))))\n\n(defn knight-quote [form]\n  (cond\n    [(symbol? form) (list 'string->symbol (symbol->string form))]\n    [(list? form) (list 'js/array &(map form knight-quote))]\n    [else form]))\n\n(hash-map-set! emit-specials 'quote emit-quote)\n\n(defn emit-return [env loc args]\n  {type: \"ReturnStatement\",\n   argument: (if (not-empty? args)\n               (emit-expression env (first args))\n               nil),\n   loc: loc})\n\n(hash-map-set! emit-specials 'js/return emit-return)\n\n(defn emit-throw [env loc args]\n  {type: \"ThrowStatement\",\n   argument: (emit-expression env (first args)),\n   loc: loc})\n\n(hash-map-set! emit-specials 'js/throw emit-throw)\n\n(defn emit-new [env loc args]\n  {type: \"NewExpression\",\n   callee: (emit-expression env (first args)),\n   arguments: (emit-expressions env (skip1 args)),\n   loc: loc})\n\n(hash-map-set! emit-specials 'js/new emit-new)\n\n(defn emit-index [env ctx args]\n  (let [obj (first args)\n        index (second args)]\n    {type: \"MemberExpression\",\n     object: (emit-expression env obj),\n     property: (emit-expression env index),\n     computed: true}))\n\n(hash-map-set! emit-specials 'js/index emit-index)\n; -*- mode: Clojure -*-\n(js/require \"source-map-support/register\")\n\n(def fs (js/require \"fs\"))\n(def path (js/require \"path\"))\n(def escodegen (js/require \"escodegen\"))\n(def terser (js/require \"terser\"))\n(def program (.-program (js/require \"commander\")))\n\n(.option program \"-o, --output <filename>\" \"Output JS filename\")\n(.option program \"-m, --map\" \"Generate source maps\")\n\n(.parse program (.-argv js/process))\n\n(let [output-filename (.-output program),\n      output-dirname (if output-filename (.dirname path output-filename)),\n      source-map-filename (if (.-map program) (if output-filename (+ (.basename path output-filename) \".map\") \"inline\")),\n      code (.readFileSync fs 0 \"utf-8\"),\n      forms (string->exprs code),\n      ast (emit-module forms),\n      output (.generate escodegen ast {sourceMap: \"stdin\", sourceMapWithCode: true, sourceContent: code}),\n      source-map (.toString (.-map output)),\n      minified (.minify terser (.-code output) {toplevel: true,\n                                                sourceMap: (if source-map-filename\n                                                             {content: source-map, url: source-map-filename})})]\n  (if (.-error minified)\n    (.error js/console (.-error minified))\n    (if output-filename\n      (do\n        (.writeFileSync fs output-filename (.-code minified))\n        (if (and source-map-filename (!= source-map-filename \"inline\"))\n          (.writeFileSync fs (.join path output-dirname source-map-filename) (.toString (.-map minified)))))\n      (println (.-code minified)))))\n"]}