{"version":3,"sources":["stdin"],"names":["hash-map","js/Map","hash-map-set!","map","key","value","set","list","items","string->symbol","string","not","contains-key?","interned-symbols","Symbol","hash-map-get","has","name","js/this","get","read","reader","skip-whitespace","c","peek-char","char-digit?","read-number","char-macro?","macro","reader-macros","read-char","token","read-token","string-prefix?","string-suffix?","substring","length","interned-keywords","Keyword","string->keyword","take-while","char","char-whitespace?","take-until","predicate","start-index","index","input-length","input","offset","not-nil?","includes","string-contains?","js/parseFloat","js/parseInt","concat","a","b","prefix","startsWith","endsWith","error","msg","js/Error","nil?","read-unicode-char","d","js/String","fromCharCode","read-until","end-char","has-indent-error","start-pos","reader-pos","start-line","line","start-indent","column","results","last-pos","pos","indent","reader-indent-warning","reader-unterminated-error","append","read-syntax","line-break","regex","cur","lastindex","match","exec","str","flags","js/RegExp","indentWarnings","push","warning","seq","w","startIndex","find","js/console","marked-line","line-index","before-line-index","after-line-index","lines","split","before-line","after-line","caret-line","string-repeat","line-num","before-line-num","after-line-num","max-line-num-width","values","js/Math","max","string-pad-start","count","repeat","toString","width","filler","padStart","form","end-pos","meta","symbol-meta","meta-set!","read-unmatched-delimiter","first-char","first","symbol->ident","symbol","ident","set-contains?","js-keywords","js-keyword?","kebabcase->camelcase","symbol->string","replace","replace-special-chars","p1","toUpperCase","second","skip2","slice","string?","not-empty?","skip1","child-env","env","hash-map-copy","variables","loopVariables","functions","functionNodes","define-function","func","symbol?","resolve-var","function-nodes","loc","func-env","emit-patterns","params","emit-return-block","body","generator","compile-function","compiler-error","js/Array","from","keys","forms","emit-pattern","array","define-variable","tag","list?","isLoop","isArray","source","start","emit-return-last","filter-not-nil","map-last","emit-statement","node","emit","expression?","statement->return","emit-return-statement","filter","last-func","item","emit-var","callee","args","field-access?","field-name","obj","emit-expression","emit-field","method-call?","method-name","method-args","emit-expressions","emit-methodcall","emit-specials","special?","emit-funcall","emit-list","emit-literal","statement->iife","statement->expression","type","expression","statements->return","test","consequent","alternate","nodes","empty?","map-not-nil","js/undefined","keyword?","keyword->string","js/Number","number?","neg","unbox","keyword","valueOf","repr","js/JSON","stringify","emit-bin-op","op","reduce","acc","arg","emit-block","single?","emit-statements","emit-vars","vars","grouped","pair","i","zip","arrays","_","knight-quote","has-more?","js/Symbol","string2","ch","escaped-char","js/Set","rest","docs","setter","emit-set-var","emit-set-field","emit-set-index","emit-setter","if-true","if-false","var","for-env","let-env","emit-cond","expr","loop-env","recur-env","ctx","js/require","fs","path","escodegen","terser","program","option","parse","js/process","argv","output-filename","output","source-map-filename","basename","code","readFileSync","ast","emit-module","read-many","make-string-reader","generate","source-map","minified","minify","writeFileSync","log","println"],"mappings":"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","sourcesContent":["; -*- mode: Clojure -*-\n\n(defn Symbol [name]\n  (set! (.-name js/this) name)\n  (js/return))\n\n(defn Keyword [name]\n  (set! (.-name js/this) name)\n  (js/return))\n\n(defn true? [value]\n  (js/=== value true))\n\n(defn false? [value]\n  (js/=== value false))\n\n(defn truthy? [value]\n  \"A value is considered truthy if it is not false and not nil (i.e., not falsy)\"\n  (js/and (js/!== value false) (js/!= value nil)))\n\n(defn falsy? [value]\n  \"A value is considered falsy if it is false or nil\"\n  (js/or (js/=== value false) (js/== value nil)))\n\n(defn not [value]\n  (js/or (js/=== value false) (js/== value nil)))\n\n(defn nil? [value]\n  (js/== value nil))\n\n(defn not-nil? [value]\n  (js/!= value nil))\n\n(defn symbol? [value]\n  (js/instanceof value Symbol))\n\n(defn keyword? [value]\n  (js/instanceof value Keyword))\n\n(defn bool? [value]\n  (js/or (js/=== (js/typeof value) \"boolean\")\n         (js/instanceof value js/Boolean)))\n\n(defn number? [value]\n  (js/or (js/=== (js/typeof value) \"number\")\n         (js/instanceof value js/Number)))\n\n(defn positive? [value]\n  (and (number? value)\n       (> value 0)))\n\n(defn negative? [value]\n  (and (number? value)\n       (< value 0)))\n\n(defn neg [value]\n  (* -1 value))\n\n(defn char? [value]\n  (js/and (js/or (js/=== (js/typeof value) \"string\")\n                 (js/instanceof value js/String))\n          (js/=== (.-length value) 1)))\n\n(defn string? [value]\n  (js/or (js/=== (js/typeof value) \"string\")\n         (js/instanceof value js/String)))\n\n(defn list? [value]\n  (.isArray js/Array value))\n\n(defn empty? [value]\n  (js/=== (.-length value) 0))\n\n(defn single? [list]\n  (and (list? list)\n       (= (.-length list) 1)))\n\n(defn not-empty? [value]\n  (and (not-nil? value)\n       (> (.-length value) 0)))\n\n(defn list [(spread items)]\n  (js/array (spread items)))\n\n(defn map [array func]\n  (.map array func))\n\n(defn map-not-nil [seq func]\n  (filter-not-nil (map seq func)))\n\n(defn map-last [array func last-func]\n  (.map array\n        (fn [item index]\n          (if (= index (- (.-length array) 1))\n            (last-func item)\n            (if (nil? func)\n              item\n              (func item))))))\n\n(defn find-first [seq predicate]\n  (.find seq predicate))\n\n(defn filter [seq predicate]\n  (.filter seq predicate))\n\n(defn filter-not-nil [seq]\n  (filter seq (fn [value] (not-nil? value))))\n\n\n(defn append [list (spread items)]\n  (js/array (spread list) (spread items)))\n\n(defn concat [a b]\n  (+ a b))\n\n(defn string-contains? [string substring]\n  (.includes string substring))\n\n(defn string-prefix? [string prefix]\n  (.startsWith string prefix))\n\n(defn string-suffix? [string prefix]\n  (.endsWith string prefix))\n\n(defn string-join [string sep]\n  (.join string sep))\n\n; (defn parse-float [string]\n;   (js/parseFloat string))\n\n; (defn parse-int [string]\n;   (js/parseInt string))\n\n(defn println [(spread args)]\n  (.log js/console (spread args)))\n\n(defn print [(spread args)]\n  (for [arg args]\n    (.write (.-stdout js/process) arg)))\n\n(defn hash-map []\n  (js/new js/Map))\n\n(defn hash-map-get [map key]\n  (.get map key))\n\n(defn hash-map-set! [map key value]\n  (.set map key value))\n\n(defn hash-map-copy [map]\n  (js/new js/Map map))\n\n(defn array-copy [array]\n  (.from js/Array array))\n\n(defn contains-key? [map key]\n  (.has map key))\n\n(def interned-symbols (hash-map))\n(def interned-keywords (hash-map))\n\n(defn string->symbol [string]\n  (if (not (contains-key? interned-symbols string))\n    (hash-map-set! interned-symbols string (js/new Symbol string)))\n  (hash-map-get interned-symbols string))\n\n(defn symbol->string [symbol]\n  (.-name symbol))\n\n(defn keyword->string [keyword]\n  (.-name keyword))\n\n(defn string->keyword [string]\n  (let [substring (if (string-prefix? string \":\")\n                    (.substring string 1)\n                    (if (string-suffix? string \":\")\n                      (.substring string 0 (- (.-length string) 1))\n                      string))]\n    (if (not (contains-key? interned-keywords substring))\n      (hash-map-set! interned-keywords substring (js/new Keyword substring)))\n    (hash-map-get interned-keywords substring)))\n\n(defn first [list]\n  (js/index list 0))\n\n(defn second [list]\n  (js/index list 1))\n\n(defn third [list]\n  (js/index list 2))\n\n(defn fourth [list]\n  (js/index list 3))\n\n(defn skip1 [list]\n  (.slice list 1))\n\n(defn skip2 [list]\n  (.slice list 2))\n\n(defn split-last [seq]\n  (js/array (.slice seq 0 (- (.-length seq) 1))\n            (js/index seq (- (.-length seq) 1))))\n\n(defn regex [str flags]\n  (js/new js/RegExp str flags))\n\n(defn error [msg]\n  (js/throw (js/new js/Error msg)))\n\n(defn tagged-list? [value tag]\n  (and (list? value)\n       (= (first value) tag)))\n\n(defn repr [value]\n  (cond\n    [(nil? value) \"nil\"]\n    [else (.stringify js/JSON value)]))\n\n(defgen grouped [seq count]\n  (loop [i 0]\n    (if (< i (.-length seq))\n      (do\n        (yield (.slice seq i (+ i count)))\n        (recur (+ i count))))))\n\n(defn zip [(spread arrays)]\n  (map (first arrays)\n       (fn [_ index]\n         (map arrays (fn [array] (js/index array index))))))\n\n(defn set [(spread values)]\n  (js/new js/Set values))\n\n(defn set-contains? [set value]\n  (.has set value))\n\n(defn box [value]\n  (cond\n    [(bool? value) (js/new js/Boolean value)]\n    [(number? value) (js/new js/Number value)]\n    [(string? value) (js/new js/String value)]\n    [else value]))\n\n(defn unbox [value]\n  (if (not-nil? value)\n    (.valueOf value)\n    nil))\n\n(def symbol-meta (js/Symbol \"meta\"))\n\n(defn meta [value]\n  (js/index value symbol-meta))\n\n(defn meta-set! [value meta]\n  (set! (js/index value symbol-meta) meta)\n  (js/return))\n\n(defn string-repeat [str count]\n  (.repeat str count))\n\n(defn string-pad-start [string width filler]\n  (.padStart string width filler))\n\n(defn string-pad-end [string width filler]\n  (.padEnd string width filler))\n\n(defn string [value]\n  (if (nil? value)\n    \"nil\"\n    (.toString value)))\n\n(defn max [(spread values)]\n  (.max js/Math (spread values)))\n; -*- mode: Clojure -*-\n\n(defn make-string-reader [string]\n  {input: string,\n   index: 0,\n   indent-warnings: (js/array)})\n\n(def reader-macros (hash-map))\n\n(defn reader-pos [reader offset]\n  (let [line-break (regex \"\\r\\n?|\\n\",\"g\"),\n        index (if (not-nil? offset)\n                (+ (.-index reader) offset)\n                (.-index reader))]\n    (loop [line 1,\n           cur 0]\n      (set! (.-lastindex line-break) cur)\n      (let [match (.exec line-break (.-input reader))]\n        (if (and match (< (.-index match) index))\n          (recur (+ line 1)\n                 (+ (.-index match) (.-length (js/index match 0))))\n          {line: line,\n           column: (- index cur)})))))\n\n(defn reader-indent [reader offset]\n  (.-column (reader-pos reader offset)))\n\n(defn reader-indent-warning [reader start-index end-char pos]\n  (.push (.-indentWarnings reader) {start-index: start-index, end-char: end-char, pos: pos}))\n\n(defn reader-unterminated-error [reader start-index start-pos end-char]\n  (let [warning (find-first (.-indentWarnings reader) (fn [w] (>= (.-startIndex w) start-index)))]\n    (.error js/console warning)\n    (error (+ \"Unexpected EOF, expected: '\" end-char \"'\\n\\n\"\n              \"Started here:\\n\"\n              (marked-line (.-input reader) start-pos) \"\\n\\n\"\n              \"Based on indent:\\n\"\n              (marked-line (.-input reader) (.-pos warning))))))\n\n(defn read-char [reader]\n  (let [char (js/index (.-input reader) (.-index reader))]\n    (set! (.-index reader) (+ (.-index reader) 1))\n    char))\n\n(defn peek-char [reader offset]\n  (js/index (.-input reader)\n            (if (not-nil? offset)\n                (+ (.-index reader) offset)\n                (.-index reader))))\n\n(defn has-more? [reader]\n  (< (.-index reader) (.-length (.-input reader))))\n\n(defn char-whitespace? [char]\n  (or (= char \\space)\n      (= char \\tab)\n      (= char \\newline)\n      (= char \\,)))\n\n(defn char-digit? [char]\n  (and (>= char \\0)\n       (<= char \\9)))\n\n(defn char-macro? [char]\n  (contains-key? reader-macros char))\n\n(defn take-until [reader predicate]\n  (let [start-index (.-index reader)\n        input-length (.-length (.-input reader))]\n    (loop [index (.-index reader)]\n      (if (or (>= index input-length)\n              (predicate (js/index (.-input reader) index)))\n        (do\n          (set! (.-index reader) index)\n          (.substring (.-input reader) start-index index))\n        (recur (+ index 1))))))\n\n(defn take-while [reader predicate]\n  (take-until reader (fn [char] (not (predicate char)))))\n\n(defn skip-whitespace [reader]\n  (loop []\n    (take-while reader (fn [char] (char-whitespace? char)))\n    (if (= (peek-char reader) \\;)\n      (do\n        (take-until reader (fn [c] (= c \\newline)))\n        (recur)))))\n\n(defn read-token [reader]\n  (concat (read-char reader)\n          (take-until reader (fn (c) (or (char-whitespace? c) (char-macro? c))))))\n\n(defn parse-token [token]\n  (cond\n    [(= token \"nil\") nil]\n    [(= token \"true\") true]\n    [(= token \"false\") false]\n    [(or (string-prefix? token \":\")\n         (string-suffix? token \":\")) (string->keyword token)]\n    [else (string->symbol token)]))\n\n(defn read-number [reader]\n  (let [string (read-token reader)]\n    (if (string-contains? string \".\")\n      (js/parseFloat string)\n      (js/parseInt string))))\n\n(defn read-character [reader]\n  (let [char (read-token reader)]\n    (cond\n      [(= char \"newline\") \\newline]\n      [(= char \"return\") \\return]\n      [(= char \"tab\") \\tab]\n      [(= char \"space\") \\space]\n      [(= (.-length char) 1) char]\n      [else (error (+ \"Unrecognized char: '\" char \"'\"))])))\n\n(defn read-quote [reader]\n  (list 'quote (read reader)))\n\n(defn read-list [reader first-char]\n  (read-until reader \\)))\n\n(defn read-array [reader first-char]\n  (read-until reader \\]))\n\n(defn read-struct [reader first-char]\n  (list 'dict (spread (read-until reader \\}))))\n\n(defn read-unmatched-delimiter [reader first-char]\n  (error (concat \"Unmatched delimiter: \" first-char)))\n\n(defn read-string [reader first-char]\n  (loop [string \"\"]\n    (let [part (take-until reader (fn [ch] (or (= ch \\\")\n                                               (= ch \\\\))))\n          string2 (concat string part)\n          char (read-char reader)]\n      (cond\n        [(nil? char) (error \"Unexpected EOF while reading string\")]\n        [(= char \\\") string2]\n        [(= char \\\\)\n         (let [char (read-char reader)\n               escaped-char (cond\n                              [(nil? char) (error \"Unexpected EOF while reading character escape\")]\n                              [(= char \\\") char]\n                              [(= char \\\\) char]\n                              [(= char \\/) char]\n                              [(= char \\n) \\newline]\n                              [(= char \\t) \\tab]\n                              [(= char \\r) \\return]\n                              [(= char \\u) (read-unicode-char reader)]\n                              [else (concat (error \"Unrecognized character escape\" char))])]\n           (recur (concat string2 escaped-char)))]))))\n\n(defn read-unicode-char [reader]\n  (let [a (read-char reader),\n        b (read-char reader),\n        c (read-char reader),\n        d (read-char reader)]\n    (.fromCharCode js/String (js/parseInt (+ a b c d)))))\n\n(defn marked-line [input pos]\n  (let [line-index (- (.-line pos) 1),\n        before-line-index (- line-index 1),\n        after-line-index (+ line-index 1),\n        lines (.split input \\newline),\n        line (js/index lines line-index),\n        before-line (or (js/index lines before-line-index) \"\"),\n        after-line (or (js/index lines after-line-index) \"\"),\n        col (.-column pos),\n        caret-line (concat (string-repeat \" \" col) \"^\"),\n        line-num (string (+ line-index 1)),\n        before-line-num (string (+ before-line-index 1)),\n        after-line-num (string (+ after-line-index 1)),\n        max-line-num-width (max (.-length line-num)\n                                (.-length before-line-num)\n                                (.-length after-line-num))]\n    (+ (string-pad-start before-line-num max-line-num-width) \" \" before-line \"\\n\"\n       (string-pad-start line-num max-line-num-width) \" \" line \"\\n\"\n       (string-repeat \" \" max-line-num-width) \" \" caret-line \"\\n\"\n       (string-pad-start after-line-num max-line-num-width) \" \" after-line)))\n\n(defn reader-error [reader pos msg]\n  (error (+ msg \"\\n\\n\" (marked-line (.-input reader) pos))))\n\n(defn read-until [reader end-char]\n  (let [has-indent-error false,\n        start-index (- (.-index reader) 1)\n        start-pos (reader-pos reader -1),\n        start-line (.-line start-pos),\n        start-indent (.-column start-pos)]\n    (loop [results (list)]\n      (if (not has-indent-error)\n        (let [last-pos (reader-pos reader)]\n          (skip-whitespace reader)\n          (let [pos (reader-pos reader),\n                line (.-line pos),\n                indent (.-column pos)]\n            (if (and (> line start-line) (<= indent start-indent))\n              (do\n                (set! has-indent-error true)\n                (reader-indent-warning reader start-index end-char last-pos))))))\n      (let [char (peek-char reader)]\n        (cond\n          [(nil? char)\n           (reader-unterminated-error reader start-index start-pos end-char)]\n          [(= char end-char)\n           (read-char reader)\n           results]\n          [else (recur (append results (read-syntax reader)))])))))\n\n(defn read [reader]\n  (skip-whitespace reader)\n  (let [c (peek-char reader)]\n    (cond\n      [(char-digit? c) (read-number reader)]\n      [(char-macro? c)\n       (let [macro (hash-map-get reader-macros c)]\n         (read-char reader)\n         (macro reader c))]\n      [(and (or (= c \\+) (= c \\-))\n            (char-digit? (peek-char reader 1)))\n       (read-number reader)]\n      [else (parse-token (read-token reader))])))\n\n(defn read-syntax [reader]\n  (let [start-pos (reader-pos reader),\n        form (read reader),\n        end-pos (reader-pos reader)]\n    (if (not-nil? form)\n      (meta-set! form {loc: {source: (.-input reader),\n                             start: start-pos,\n                             end: end-pos}}))\n    form))\n\n(defn read-many [reader]\n  (loop [results (list)]\n    (skip-whitespace reader)\n    (if (has-more? reader)\n      (recur (append results (read-syntax reader)))\n      results)))\n\n(defn string->expr [str]\n  (read-syntax (make-string-reader str)))\n\n(defn string->exprs [str]\n  (read-many (make-string-reader str)))\n\n(hash-map-set! reader-macros \\' read-quote)\n(hash-map-set! reader-macros \\\\ read-character)\n(hash-map-set! reader-macros \\\" read-string)\n(hash-map-set! reader-macros \\( read-list)\n(hash-map-set! reader-macros \\) read-unmatched-delimiter)\n(hash-map-set! reader-macros \\[ read-array)\n(hash-map-set! reader-macros \\] read-unmatched-delimiter)\n(hash-map-set! reader-macros \\{ read-struct)\n(hash-map-set! reader-macros \\} read-unmatched-delimiter)\n; -*- mode: Clojure -*-\n\n(def js-keywords (set \"var\" \"let\" \"const\"))\n\n(defn compiler-error [form msg]\n  (if (and (meta form) (.-loc (meta form)))\n    (let [loc (.-loc (meta form)),\n          source (.-source loc),\n          pos (.-start loc)]\n      (error (+ msg \"\\n\\n\" (marked-line source pos))))\n    (error msg)))\n\n(defn make-env []\n  {functions: (hash-map),\n   function-nodes: (hash-map),\n   variables: (hash-map),\n   is-loop: false})\n\n(defn child-env [env]\n  {variables: (hash-map-copy (.-variables env))\n   loop-variables: (.-loopVariables env),\n   functions: (.-functions env),\n   function-nodes: (.-functionNodes env),\n   is-loop: false})\n\n(defn recur-env [env]\n  {variables: (hash-map-copy (.-variables env))\n   loop-variables: (js/array),\n   functions: (.-functions env),\n   function-nodes: (.-functionNodes env),\n   is-loop: true})\n\n(defn replace-special-chars [ident]\n  (.replace (.replace (.replace (.replace ident \"!\" \"\")\n                                \"->\" \"-to-\")\n                      (regex \"^((contains|has).*)\\\\?$\") \"$1\")\n            (regex \"^(.*)\\\\?$\") \"is-$1\"))\n\n(defn kebabcase->camelcase [ident]\n  (.replace (replace-special-chars ident)\n            (regex \"[-_]([a-zA-Z])\" \"g\")\n            (fn [match p1] (.toUpperCase p1))))\n\n(defn sanitize-js-keywords [ident]\n  (if (js-keyword? ident)\n    (concat ident \"$\")\n    ident))\n\n(defn symbol->ident [symbol]\n  (cond\n    [(= symbol 'Symbol) \"LispSymbol\"]\n    [else (sanitize-js-keywords (kebabcase->camelcase (symbol->string symbol)))]))\n\n(defn define-variable [env symbol]\n  (let [variables (.-variables env)]\n    (if (not (contains-key? variables symbol))\n      (hash-map-set! variables symbol (symbol->ident symbol)))\n    (if (.-isLoop env)\n      (.push (.-loopVariables env) symbol))\n    (resolve-var env symbol)))\n\n(defn define-function [env name func]\n  (let [functions (.-functions env)]\n    (if (contains-key? functions name)\n      (error (+ \"Function already defined: \" (symbol->string name)))\n      (hash-map-set! functions name func))\n    nil))\n\n(defn resolve-var [env symbol]\n  (let [variables (.-variables env),\n        functions (.-functions env),\n        function-nodes (.-functionNodes env),\n        string (symbol->string symbol),\n        loc (if (meta symbol) (.-loc (meta symbol)))]\n    (cond\n      [(string-prefix? string \"js/\")\n       {type: \"Identifier\",\n        name: (.substring string 3),\n        originalName: string,\n        loc: loc}]\n      [(contains-key? variables symbol)\n       {type: \"Identifier\",\n        name: (hash-map-get variables symbol),\n        originalName: string,\n        loc: loc}]\n      [(contains-key? functions symbol)\n       (if (not (contains-key? function-nodes symbol))\n         (compile-function env (hash-map-get functions symbol)))\n       {type: \"Identifier\",\n        name: (.-ident (hash-map-get functions symbol)),\n        originalName: string,\n        loc: loc}]\n      [else\n       (compiler-error symbol (+ \"Variable or function not found: \" string \" - \"\n                                 (map (.from js/Array (.keys variables)) symbol->string) \" - \"\n                                 (map (.from js/Array (.keys functions)) symbol->string)))])))\n\n(defn compile-function [env func]\n  (let [func-env (child-env env)]\n    (hash-map-set! (.-functionNodes env)\n                   (.-name func) 'placeholder)\n    (hash-map-set! (.-functionNodes env)\n                   (.-name func)\n                   {type: \"FunctionDeclaration\",\n                    id: {type: \"Identifier\",\n                         name: (.-ident func),\n                         originalName: (symbol->string (.-name func)),\n                         loc: (.-loc (meta (.-name func)))},\n                    params: (emit-patterns func-env (.-params func)),\n                    body: (emit-return-block func-env (.-body func)),\n                    generator: (.-generator func),\n                    loc: (.-loc func)})))\n; -*- mode: Clojure -*-\n\n(def emit-specials (hash-map))\n\n;; Predicates\n\n(defn field-access? [form]\n  (and (symbol? form)\n       (string-prefix? (symbol->string form) \".-\")))\n\n(defn method-call? [form]\n  (and (symbol? form)\n       (string-prefix? (symbol->string form) \".\")))\n\n(defn special? [form]\n  (and (symbol? form)\n       (contains-key? emit-specials form)))\n\n(defn js-keyword? [ident]\n  (set-contains? js-keywords ident))\n\n(defn expression? [node]\n  (let [type (.-type node)]\n    (or (= type \"Literal\")\n        (= type \"Identifier\")\n        (string-suffix? type \"Expression\")\n        (string-suffix? type \"Element\"))))\n\n;; AST Transformation\n\n(defn statement->iife [node]\n  {type: \"CallExpression\",\n   callee: {type: \"ArrowFunctionExpression\",\n            id: nil,\n            params: (js/array),\n            body: {type: \"BlockStatement\",\n                   body: (js/array (statement->return node)),\n                   loc: (.-loc node)}},\n   arguments: (js/array)})\n\n(defn statement->expression [node]\n  (statement->iife node))\n\n(defn statements->return [nodes]\n  (if (empty? nodes)\n    (js/array {:type \"ReturnStatement\",\n               :argument nil})\n    (map-last nodes nil statement->return)))\n\n(defn statement->return [node]\n  (let [type (.-type node)]\n    (cond\n      [(= type \"ReturnStatement\") node]\n      [(= type \"ForOfStatement\") node]\n      [(= type \"ContinueStatement\") node]\n      [(= type \"ThrowStatement\") node]\n      [(= type \"ExpressionStatement\")\n       {type: \"ReturnStatement\",\n        argument: (.-expression node),\n        loc: (.-loc node)}]\n      [(= type \"BlockStatement\")\n       {type: \"BlockStatement\",\n        body: (statements->return (.-body node)),\n        loc: (.-loc node)}]\n      [(= type \"WhileStatement\")\n       {type: \"WhileStatement\",\n        test: (.-test node),\n        body: (statement->return (.-body node)),\n        loc: (.-loc node)}]\n      [(= type \"IfStatement\")\n       {type: \"IfStatement\",\n        test: (.-test node),\n        consequent: (statement->return (.-consequent node)),\n        alternate: (if (.-alternate node)\n                       (statement->return (.-alternate node))\n                       nil),\n        loc: (.-loc node)}]\n      [else (error (concat \"Unsupported return statement: \" type))])))\n\n;; AST Generation of specific types\n\n(defn emit-return-last [env forms]\n  (filter-not-nil (map-last forms (fn [form] (emit-statement env form))\n                                  (fn [form] (emit-return-statement env form)))))\n\n(defn emit-return-block [env forms]\n  {type: \"BlockStatement\",\n   body: (emit-return-last env forms)})\n\n(defn emit-return-statement [env form]\n  (let [node (emit env form)]\n    (if (expression? node)\n      {type: \"ReturnStatement\",\n       argument: node,\n       loc: (.-loc node)}\n      (statement->return node))))\n\n(defn emit-statements [env forms]\n  (map-not-nil forms (fn [form] (emit-statement env form))))\n\n(defn emit-statement [env form]\n  (let [node (emit env form)]\n    (cond\n      [(nil? node) node]\n      [(expression? node)\n       {type: \"ExpressionStatement\",\n        expression: node,\n        loc: (.-loc node)}]\n      [else node])))\n\n(defn emit-expressions [env forms]\n  (map-not-nil forms (fn [form] (emit-expression env form))))\n\n(defn emit-expression [env form]\n  (let [node (emit env form)]\n    (cond\n      [(nil? node) node]\n      [(expression? node) node]\n      [else (statement->expression node)])))\n\n(defn emit-patterns [env forms]\n  (map forms (fn [form] (emit-pattern env form))))\n\n(defn emit-pattern [env form]\n  (cond\n    [(symbol? form)\n     (define-variable env form)]\n    [(tagged-list? form 'spread)\n     {type: \"RestElement\",\n      argument: (define-variable env (second form)),\n      loc: (.-loc (meta form))}]\n    [(list? form)\n     {type: \"ArrayPattern\",\n      elements: (emit-patterns env form)}]\n    [else (compiler-error form \"Unrecognized pattern\")]))\n\n(defn emit-block [env forms]\n  (if (single? forms)\n    (emit-statement env (first forms))\n    {type: \"BlockStatement\",\n     body: (emit-statements env forms)}))\n\n;; AST Generation\n\n(defn emit-module [forms]\n  (let [env (make-env),\n        nodes (emit-statements env forms),\n        function-nodes (.-functionNodes env)]\n    {type: \"Program\",\n     body: (js/array (spread (.values function-nodes)) (spread nodes))}))\n\n(defn emit [env form]\n  (cond\n    [(symbol? form) (emit-var env form)]\n    [(list? form) (emit-list env form)]\n    [else (emit-literal env form)]))\n\n(defn emit-literal [env form]\n  (cond\n    [(js/=== form js/undefined) (error \"Undefined!\")]\n    [(keyword? form) (emit env (list 'string->keyword (keyword->string form)))]\n    [(negative? form)\n     {type: \"UnaryExpression\",\n      operator: \"-\",\n      prefix: true,\n      argument: {type: \"Literal\",\n                 value: (neg (unbox form))},\n      loc: (if (and (not-nil? form) (meta form)) (.-loc (meta form)))}]\n    [else {type: \"Literal\",\n           value: (unbox form),\n           loc: (if (and (not-nil? form) (meta form)) (.-loc (meta form)))}]))\n\n(defn emit-var [env symbol]\n  (resolve-var env symbol))\n\n(defn emit-list [env form]\n  (let [loc (if (meta form) (.-loc (meta form))),\n        callee (first form),\n        args (skip1 form)]\n    (cond\n      [(field-access? callee) (emit-field env loc callee args)]\n      [(method-call? callee) (emit-methodcall env loc callee args)]\n      [(special? callee) ((hash-map-get emit-specials callee) env loc args)]\n      [else (emit-funcall env loc callee args)])))\n\n(defn emit-field [env loc callee args]\n  (let [field-name (.substring (symbol->string callee) 2)\n        obj (first args)]\n    {type: \"MemberExpression\",\n     object: (emit-expression env obj),\n     property: {type: \"Identifier\",\n                name: field-name,\n                loc: (.-loc (meta callee))},\n     computed: false,\n     loc: loc}))\n\n(defn emit-methodcall [env loc callee args]\n  (let [method-name (.substring (symbol->string callee) 1)\n        obj (first args)\n        method-args (skip1 args)]\n    {type: \"CallExpression\",\n     callee: {type: \"MemberExpression\",\n              object: (emit-expression env obj),\n              property: {type: \"Identifier\",\n                         name: method-name,\n                         loc: (.-loc (meta callee))},\n              computed: false},\n     arguments: (emit-expressions env method-args),\n     loc: loc}))\n\n(defn emit-funcall [env loc callee args]\n  {type: \"CallExpression\",\n   callee: (emit-expression env callee),\n   arguments: (emit-expressions env args),\n   loc: loc})\n\n(defn emit-defn [env loc args]\n  (let [name (first args)\n        ident (symbol->ident name)\n        params (second args)\n        rest (skip2 args)\n        docs (if (and (string? (first rest))\n                      (not-empty? (skip1 rest)))\n                 (first rest))\n        body (if docs (skip1 rest) rest)\n        func-env (child-env env)]\n    (define-function env name {name: name,\n                               ident: ident,\n                               params: params,\n                               docs: docs,\n                               body: body,\n                               loc: loc,\n                               generator: false})))\n\n(hash-map-set! emit-specials 'defn emit-defn)\n\n(defn emit-defgen [env loc args]\n  (let [name (first args)\n        ident (symbol->ident name)\n        params (second args)\n        rest (skip2 args)\n        docs (if (and (string? (first rest))\n                      (not-empty? (skip1 rest)))\n                 (first rest))\n        body (if docs (skip1 rest) rest)\n        func-env (child-env env)]\n    (define-function env name {name: name,\n                               ident: ident,\n                               params: params,\n                               docs: docs,\n                               body: body,\n                               loc: loc,\n                               generator: true})))\n\n(hash-map-set! emit-specials 'defgen emit-defgen)\n\n(defn emit-set [env loc args]\n  (let [setter (first args)\n        value (second args)]\n    (cond\n      [(symbol? setter) (emit-set-var env loc setter value)]\n      [(list? setter) (emit-setter env loc setter value)]\n      [else (error (concat \"Invalid setter: \" (repr setter)))])))\n\n(defn emit-setter [env loc setter value]\n  (let [callee (first setter)\n        args (skip1 setter)]\n    (cond\n      [(field-access? callee) (emit-set-field env loc callee args value)]\n      [(= callee 'js/index) (emit-set-index env loc args value)]\n      [else (error (concat \"Invalid setter: \" (repr setter)))])))\n\n(defn emit-set-var [env loc symbol value]\n  {type: \"AssignmentExpression\",\n   operator: \"=\",\n   left: (resolve-var env symbol),\n   right: (emit-expression env value),\n   loc: loc})\n\n(defn emit-set-field [env loc symbol args value]\n  (let [field-name (.substring (symbol->string symbol) 2)\n        obj (first args)]\n    {type: \"AssignmentExpression\",\n     operator: \"=\",\n     left: {type: \"MemberExpression\",\n            object: (emit-expression env obj),\n            property: {type: \"Identifier\",\n                       name: field-name,\n                       loc: (.-loc (meta symbol))},\n            computed: false},\n     right: (emit-expression env value),\n     loc: loc}))\n\n(defn emit-set-index [env loc args value]\n  (let [obj (first args)\n        index (second args)]\n    {type: \"AssignmentExpression\",\n     operator: \"=\",\n     left: {type: \"MemberExpression\",\n            object: (emit-expression env obj),\n            property: (emit-expression env index),\n            computed: true},\n     right: (emit-expression env value),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'set! emit-set)\n\n(defn emit-bin-op [op]\n  (fn [env loc args]\n    (if (empty? args)\n      (error \"Empty operator expression\"))\n    (.reduce (emit-expressions env args)\n            (fn [acc, arg]\n              {type: \"BinaryExpression\",\n               operator: op,\n               left: acc,\n               right: arg,\n               loc: loc}))))\n\n(hash-map-set! emit-specials 'and (emit-bin-op \"&&\"))\n(hash-map-set! emit-specials 'or (emit-bin-op \"||\"))\n(hash-map-set! emit-specials 'js/and (emit-bin-op \"&&\"))\n(hash-map-set! emit-specials 'js/or (emit-bin-op \"||\"))\n(hash-map-set! emit-specials 'js/=== (emit-bin-op \"===\"))\n(hash-map-set! emit-specials 'js/!== (emit-bin-op \"!==\"))\n(hash-map-set! emit-specials 'js/== (emit-bin-op \"==\"))\n(hash-map-set! emit-specials 'js/!= (emit-bin-op \"!=\"))\n(hash-map-set! emit-specials '= (emit-bin-op \"===\"))\n(hash-map-set! emit-specials '!= (emit-bin-op \"!==\"))\n(hash-map-set! emit-specials '>= (emit-bin-op \">=\"))\n(hash-map-set! emit-specials '<= (emit-bin-op \"<=\"))\n(hash-map-set! emit-specials '> (emit-bin-op \">\"))\n(hash-map-set! emit-specials '< (emit-bin-op \"<\"))\n(hash-map-set! emit-specials '+ (emit-bin-op \"+\"))\n(hash-map-set! emit-specials '- (emit-bin-op \"-\"))\n(hash-map-set! emit-specials '* (emit-bin-op \"*\"))\n(hash-map-set! emit-specials '/ (emit-bin-op \"/\"))\n(hash-map-set! emit-specials 'mod (emit-bin-op \"%\"))\n(hash-map-set! emit-specials 'js/instanceof (emit-bin-op \"instanceof\"))\n\n(defn emit-spread [env loc args]\n  {type: \"SpreadElement\",\n   argument: (emit-expression env (first args)),\n   loc: loc})\n\n(hash-map-set! emit-specials 'spread emit-spread)\n\n(defn emit-array [env loc args]\n  {type: \"ArrayExpression\",\n   elements: (emit-expressions env args),\n   loc: loc})\n\n(hash-map-set! emit-specials 'js/array emit-array)\n\n(defn emit-fn [env loc args]\n  (let [params (first args)\n        body (skip1 args)\n        func-env (child-env env)]\n    {type: \"ArrowFunctionExpression\",\n     id: nil,\n     params: (emit-patterns func-env params),\n     body: (emit-return-block func-env body),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'fn emit-fn)\n\n(defn emit-if [env loc args]\n  (let [test (first args)\n        if-true (second args)\n        if-false (skip2 args)]\n    {type: \"IfStatement\",\n     test: (emit-expression env test),\n     consequent: (emit-statement env if-true),\n     alternate: (if (not-nil? if-false) (emit-block env if-false)),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'if emit-if)\n\n(defn emit-for [env loc args]\n  (let [var (first (first args))\n        value (second (first args))\n        body (skip1 args)\n        for-env (child-env env)]\n    {type: \"ForOfStatement\",\n     left: (emit-pattern for-env var),\n     right: (emit-expression for-env value),\n     body: (emit-block for-env body),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'for emit-for)\n\n(defn emit-def [env loc args]\n  {type: \"VariableDeclaration\",\n   kind: \"let\",\n   declarations: (js/array {type: \"VariableDeclarator\",\n                            id: (define-variable env (first args)),\n                            init: (emit-expression env (second args)),\n                            loc: loc}),\n   loc: loc})\n\n(hash-map-set! emit-specials 'def emit-def)\n\n(defn emit-vars [env vars]\n  {type: \"VariableDeclaration\",\n   kind: \"let\",\n   declarations: (map (.from js/Array (grouped vars 2))\n                      (fn [pair]\n                        {type: \"VariableDeclarator\",\n                         id: (define-variable env (first pair)),\n                         init: (emit-expression env (second pair))})),\n   loc: (.-loc (meta vars))})\n\n(defn emit-let [env loc args]\n  (let [vars (first args)\n        body (skip1 args)\n        let-env (child-env env)]\n    {type: \"BlockStatement\",\n     body: (js/array (emit-vars let-env vars) (spread (emit-statements let-env body))),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'let emit-let)\n\n(defn emit-cond [env loc args]\n  (let [expr (first args),\n        rest (skip1 args),\n        test (first expr),\n        body (skip1 expr)]\n    (if (= test 'else)\n      (emit-block env body)\n      {type: \"IfStatement\",\n       test: (emit-expression env test),\n       consequent: (emit-block env body),\n       alternate: (if (not-empty? rest) (emit-cond env loc rest))})))\n\n(hash-map-set! emit-specials 'cond emit-cond)\n\n(defn emit-loop [env loc args]\n  (let [vars (first args)\n        body (skip1 args)\n        loop-env (recur-env env)]\n    (if (empty? vars)\n      {type: \"WhileStatement\",\n       test: (emit-literal loop-env true),\n       body: (emit-return-block loop-env body)}\n      {type: \"BlockStatement\",\n       body: (js/array (emit-vars loop-env vars)\n                       {type: \"WhileStatement\",\n                        test: (emit-literal loop-env true),\n                        body: (emit-return-block loop-env body)})})))\n\n(hash-map-set! emit-specials 'loop emit-loop)\n\n(defn emit-do [env loc args]\n  {type: \"BlockStatement\",\n   body: (emit-statements env args),\n   loc: loc})\n\n(hash-map-set! emit-specials 'do emit-do)\n\n(defn emit-yield [env loc args]\n  {type: \"YieldExpression\",\n   argument: (emit-expression env (first args)),\n   loc: loc})\n\n(hash-map-set! emit-specials 'yield emit-yield)\n\n(defn emit-recur [env loc args]\n  (if (!= (.-length (.-loopVariables env)) (.-length args))\n    (error (+ \"Recur with not enough args\" (.-length (.-loopVariables env)) (.-length args))))\n  (if (empty? args)\n    {type: \"ContinueStatement\",\n     loc: loc}\n    {type: \"BlockStatement\",\n     body: (js/array (spread (map (zip (.-loopVariables env) args)\n                                  (fn [pair]\n                                    {type: \"ExpressionStatement\",\n                                     expression: {type: \"AssignmentExpression\",\n                                                  operator: \"=\",\n                                                  left: (emit-pattern env (first pair)),\n                                                  right: (emit-expression env (second pair))}})))\n                    {type: \"ContinueStatement\"}),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'recur emit-recur)\n\n(defn emit-dict [env ctx args]\n  {type: \"ObjectExpression\",\n   properties: (map (.from js/Array (grouped args 2))\n                    (fn [pair]\n                      {type: \"Property\",\n                       key: (if (keyword? (first pair))\n                              (emit-literal env (kebabcase->camelcase (keyword->string (first pair))))\n                              (emit-literal env (first pair))),\n                       value: (emit-expression env (second pair))}))})\n\n(hash-map-set! emit-specials 'dict emit-dict)\n\n(defn emit-quote [env loc args]\n  (emit env (knight-quote (first args))))\n\n(defn knight-quote [form]\n  (cond\n    [(symbol? form) (list 'string->symbol (symbol->string form))]\n    [(list? form) (append (list 'js/array) (map knight-quote form))]\n    [else form]))\n\n(hash-map-set! emit-specials 'quote emit-quote)\n\n(defn emit-return [env loc args]\n  {type: \"ReturnStatement\",\n   argument: (if (not-empty? args)\n               (emit-expression env (first args))\n               nil),\n   loc: loc})\n\n(hash-map-set! emit-specials 'js/return emit-return)\n\n(defn emit-throw [env loc args]\n  {type: \"ThrowStatement\",\n   argument: (emit-expression env (first args)),\n   loc: loc})\n\n(hash-map-set! emit-specials 'js/throw emit-throw)\n\n(defn emit-new [env loc args]\n  {type: \"NewExpression\",\n   callee: (emit-expression env (first args)),\n   arguments: (emit-expressions env (skip1 args)),\n   loc: loc})\n\n(hash-map-set! emit-specials 'js/new emit-new)\n\n(defn emit-index [env ctx args]\n  (let [obj (first args)\n        index (second args)]\n    {type: \"MemberExpression\",\n     object: (emit-expression env obj),\n     property: (emit-expression env index),\n     computed: true}))\n\n(hash-map-set! emit-specials 'js/index emit-index)\n; -*- mode: Clojure -*-\n(js/require \"source-map-support/register\")\n\n(def fs (js/require \"fs\"))\n(def path (js/require \"path\"))\n(def escodegen (js/require \"escodegen\"))\n(def terser (js/require \"terser\"))\n(def program (.-program (js/require \"commander\")))\n\n(.option program \"-o, --output <filename>\" \"Output JS filename\")\n(.option program \"-m, --map\" \"Generate source maps\")\n\n(.parse program (.-argv js/process))\n\n(let [output-filename (.-output program),\n      source-map-filename (if (.-map program) (if output-filename (+ (.basename path output-filename) \".map\") \"inline\")),\n      code (.readFileSync fs 0 \"utf-8\"),\n      forms (string->exprs code),\n      ast (emit-module forms),\n      output (.generate escodegen ast {sourceMap: \"stdin\", sourceMapWithCode: true, sourceContent: code}),\n      source-map (.toString (.-map output)),\n      minified (.minify terser (.-code output) {toplevel: true,\n                                                sourceMap: (if source-map-filename\n                                                             {content: source-map, url: source-map-filename})})]\n  (if (.-error minified)\n    (.error js/console (.-error minified))\n    (if output-filename\n      (do\n        (.writeFileSync fs output-filename (.-code minified))\n        (if (and source-map-filename (!= source-map-filename \"inline\"))\n          (.writeFileSync fs source-map-filename (.toString (.-map minified)))))\n      (println (.-code minified)))))\n"]}