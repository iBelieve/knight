{"version":3,"sources":["stdin"],"names":["Symbol","name","js/this","Keyword","not","value","nil?","not-nil?","symbol?","keyword?","string?","js/String","list?","js/Array","isArray","empty?","length","not-empty?","list","items","map","array","func","map-last","last-func","item","index","append","concat","a","b","string-prefix?","string","prefix","startsWith","string-suffix?","endsWith","hash-map","js/Map","hash-map-get","key","get","hash-map-set!","set","hash-map-copy","contains-key?","has","interned-symbols","interned-keywords","string->symbol","symbol->string","symbol","keyword->string","keyword","first","second","skip1","slice","skip2","regex","str","flags","js/RegExp","error","msg","js/Error","tagged-list?","tag","repr","js/JSON","stringify","grouped","seq","count","i","zip","arrays","_","symbol-meta","js/Symbol","meta","make-string-reader","reader-macros","reader-pos","reader","line-break","line","cur","lastindex","match","exec","input","read-char","char","peek-char","has-more?","char-whitespace?","char-macro?","take-until","predicate","start-index","input-length","substring","take-while","skip-whitespace","c","read-token","parse-token","token","string->keyword","read-unmatched-delimiter","first-char","read-unicode-char","d","fromCharCode","js/parseInt","read-until","end-char","results","read-syntax","read","includes","string-contains?","js/parseFloat","read-number","macro","start-pos","form","end-pos","meta-set!","string2","ch","escaped-char","js-keywords","values","js/Set","emit-specials","field-access?","expression?","node","type","compiler-error","loc","line-index","start","after-line-index","before-line-index","lines","source","split","after-line","before-line","col","column","repeat","child-env","env","variables","loopVariables","from","kebabcase->camelcase","ident","replace","replace-special-chars","p1","toUpperCase","sanitize-js-keywords","set-contains?","js-keyword?","symbol->ident","define-variable","isLoop","push","resolve-var","define-function","statement->expression","statement->return","statement->iife","expression","nodes","body","test","consequent","alternate","emit-return-last","forms","emit-statement","emit","emit-return-statement","emit-return-block","emit-statements","emit-expressions","emit-expression","emit-patterns","emit-pattern","emit-block","single?","emit-var","callee","args","field-name","obj","emit-field","method-call?","method-name","method-args","emit-methodcall","special?","emit-funcall","emit-list","emit-literal","js/undefined","valueOf","emit-return","emit-bin-op","op","reduce","acc","arg","emit-vars","vars","pair","knight-quote","params","rest","func-env","setter","emit-set-var","emit-set-field","emit-set-index","emit-setter","if-true","if-false","var","for-env","let-env","emit-branch","expr","loop-env","recur-env","ctx","js/require","fs","escodegen","terser","program","option","parse","js/process","argv","output-filename","output","source-map-filename","code","readFileSync","ast","emit-module","read-many","generate","source-map","toString","minified","minify","js/console","writeFileSync","log","println"],"mappings":"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","sourcesContent":["; -*- mode: Clojure -*-\n\n(defn Symbol [name]\n  (set! (.-name js/this) name)\n  (js/return))\n\n(defn Keyword [name]\n  (set! (.-name js/this) name)\n  (js/return))\n\n(defn true? [value]\n  (js/=== value true))\n\n(defn false? [value]\n  (js/=== value false))\n\n(defn truthy? [value]\n  \"A value is considered truthy if it is not false and not nil (i.e., not falsy)\"\n  (js/and (js/!== value false) (js/!= value nil)))\n\n(defn falsy? [value]\n  \"A value is considered falsy if it is false or nil\"\n  (js/or (js/=== value false) (js/== value nil)))\n\n(defn not [value]\n  (js/or (js/=== value false) (js/== value nil)))\n\n(defn nil? [value]\n  (js/== value nil))\n\n(defn not-nil? [value]\n  (js/!= value nil))\n\n(defn symbol? [value]\n  (js/instanceof value Symbol))\n\n(defn keyword? [value]\n  (js/instanceof value Keyword))\n\n(defn bool? [value]\n  (js/or (js/=== (js/typeof value) \"boolean\")\n         (js/instanceof value js/Boolean)))\n\n(defn number? [value]\n  (js/or (js/=== (js/typeof value) \"number\")\n         (js/instanceof value js/Number)))\n\n(defn char? [value]\n  (js/and (js/or (js/=== (js/typeof value) \"string\")\n                 (js/instanceof value js/String))\n          (js/=== (.-length value) 1)))\n\n(defn string? [value]\n  (js/or (js/=== (js/typeof value) \"string\")\n         (js/instanceof value js/String)))\n\n(defn list? [value]\n  (.isArray js/Array value))\n\n(defn empty? [value]\n  (js/=== (.-length value) 0))\n\n(defn single? [list]\n  (and (list? list)\n       (= (.-length list) 1)))\n\n(defn not-empty? [value]\n  (and (not-nil? value)\n       (> (.-length value) 0)))\n\n(defn list [(spread items)]\n  (js/array (spread items)))\n\n(defn map [array func]\n  (.map array func))\n\n(defn map-last [array func last-func]\n  (.map array\n        (fn [item index]\n          (if (= index (- (.-length array) 1))\n            (last-func item)\n            (if (nil? func)\n              item\n              (func item))))))\n\n(defn append [list (spread items)]\n  (js/array (spread list) (spread items)))\n\n(defn concat [a b]\n  (+ a b))\n\n(defn string-contains? [string substring]\n  (.includes string substring))\n\n(defn string-prefix? [string prefix]\n  (.startsWith string prefix))\n\n(defn string-suffix? [string prefix]\n  (.endsWith string prefix))\n\n(defn string-join [string sep]\n  (.join string sep))\n\n; (defn parse-float [string]\n;   (js/parseFloat string))\n\n; (defn parse-int [string]\n;   (js/parseInt string))\n\n(defn println [(spread args)]\n  (.log js/console (spread args)))\n\n(defn print [(spread args)]\n  (for [arg args]\n    (.write (.-stdout js/process) arg)))\n\n(defn hash-map []\n  (js/new js/Map))\n\n(defn hash-map-get [map key]\n  (.get map key))\n\n(defn hash-map-set! [map key value]\n  (.set map key value))\n\n(defn hash-map-copy [map]\n  (js/new js/Map map))\n\n(defn array-copy [array]\n  (.from js/Array array))\n\n(defn contains-key? [map key]\n  (.has map key))\n\n(def interned-symbols (hash-map))\n(def interned-keywords (hash-map))\n\n(defn string->symbol [string]\n  (if (not (contains-key? interned-symbols string))\n    (hash-map-set! interned-symbols string (js/new Symbol string)))\n  (hash-map-get interned-symbols string))\n\n(defn symbol->string [symbol]\n  (.-name symbol))\n\n(defn keyword->string [keyword]\n  (.-name keyword))\n\n(defn string->keyword [string]\n  (let [substring (if (string-prefix? string \":\")\n                    (.substring string 1)\n                    (if (string-suffix? string \":\")\n                      (.substring string 0 (- (.-length string) 1))\n                      string))]\n    (if (not (contains-key? interned-keywords substring))\n      (hash-map-set! interned-keywords substring (js/new Keyword substring)))\n    (hash-map-get interned-keywords substring)))\n\n(defn first [list]\n  (js/index list 0))\n\n(defn second [list]\n  (js/index list 1))\n\n(defn third [list]\n  (js/index list 2))\n\n(defn fourth [list]\n  (js/index list 3))\n\n(defn skip1 [list]\n  (.slice list 1))\n\n(defn skip2 [list]\n  (.slice list 2))\n\n(defn split-last [seq]\n  (js/array (.slice seq 0 (- (.-length seq) 1))\n            (js/index seq (- (.-length seq) 1))))\n\n(defn regex [str flags]\n  (js/new js/RegExp str flags))\n\n(defn error [msg]\n  (js/throw (js/new js/Error msg)))\n\n(defn tagged-list? [value tag]\n  (and (list? value)\n       (= (first value) tag)))\n\n(defn repr [value]\n  (cond\n    [(nil? value) \"nil\"]\n    [else (.stringify js/JSON value)]))\n\n(defgen grouped [seq count]\n  (loop [i 0]\n    (if (< i (.-length seq))\n      (do\n        (yield (.slice seq i (+ i count)))\n        (recur (+ i count))))))\n\n(defn zip [(spread arrays)]\n  (map (first arrays)\n       (fn [_ index]\n         (map arrays (fn [array] (js/index array index))))))\n\n(defn set [(spread values)]\n  (js/new js/Set values))\n\n(defn set-contains? [set value]\n  (.has set value))\n\n(defn box [value]\n  (cond\n    [(bool? value) (js/new js/Boolean value)]\n    [(number? value) (js/new js/Number value)]\n    [(string? value) (js/new js/String value)]\n    [else value]))\n\n(defn unbox [value]\n  (if (not-nil? value)\n    (.valueOf value)\n    nil))\n\n(def symbol-meta (js/Symbol \"meta\"))\n\n(defn meta [value]\n  (js/index value symbol-meta))\n\n(defn meta-set! [value meta]\n  (set! (js/index value symbol-meta) meta)\n  (js/return))\n\n(defn string-repeat [str count]\n  (.repeat str count))\n; -*- mode: Clojure -*-\n\n(defn make-string-reader [string]\n  {input: string,\n   index: 0})\n\n(def reader-macros (hash-map))\n\n(defn reader-pos [reader]\n  (let [line-break (regex \"\\r\\n?|\\n\",\"g\")]\n    (loop [line 1,\n           cur 0]\n      (set! (.-lastindex line-break) cur)\n      (let [match (.exec line-break (.-input reader))]\n        (if (and match (< (.-index match) (.-index reader)))\n          (recur (+ line 1)\n                 (+ (.-index match) (.-length (js/index match 0))))\n          {line: line,\n           column: (- (.-index reader) cur)})))))\n\n(defn read-char [reader]\n  (let [char (js/index (.-input reader) (.-index reader))]\n    (set! (.-index reader) (+ (.-index reader) 1))\n    char))\n\n(defn peek-char [reader]\n  (js/index (.-input reader) (.-index reader)))\n\n(defn has-more? [reader]\n  (< (.-index reader) (.-length (.-input reader))))\n\n(defn char-whitespace? [char]\n  (or (= char \\space)\n      (= char \\tab)\n      (= char \\newline)\n      (= char \\,)))\n\n(defn char-digit? [char]\n  (and (>= char \\0)\n       (<= char \\9)))\n\n(defn char-macro? [char]\n  (contains-key? reader-macros char))\n\n(defn take-until [reader predicate]\n  (let [start-index (.-index reader)\n        input-length (.-length (.-input reader))]\n    (loop [index (.-index reader)]\n      (if (or (>= index input-length)\n              (predicate (js/index (.-input reader) index)))\n        (do\n          (set! (.-index reader) index)\n          (.substring (.-input reader) start-index index))\n        (recur (+ index 1))))))\n\n(defn take-while [reader predicate]\n  (take-until reader (fn [char] (not (predicate char)))))\n\n(defn skip-whitespace [reader]\n  (loop []\n    (take-while reader (fn [char] (char-whitespace? char)))\n    (if (= (peek-char reader) \\;)\n      (do\n        (take-until reader (fn [c] (= c \\newline)))\n        (recur)))))\n\n(defn read-token [reader]\n  (concat (read-char reader)\n          (take-until reader (fn (c) (or (char-whitespace? c) (char-macro? c))))))\n\n(defn parse-token [token]\n  (cond\n    [(= token \"nil\") nil]\n    [(= token \"true\") true]\n    [(= token \"false\") false]\n    [(or (string-prefix? token \":\")\n         (string-suffix? token \":\")) (string->keyword token)]\n    [else (string->symbol token)]))\n\n(defn read-number [reader]\n  (let [string (read-token reader)]\n    (if (string-contains? string \".\")\n      (js/parseFloat string)\n      (js/parseInt string))))\n\n(defn read-character [reader]\n  (let [char (read-token reader)]\n    (cond\n      [(= char \"newline\") \\newline]\n      [(= char \"return\") \\return]\n      [(= char \"tab\") \\tab]\n      [(= char \"space\") \\space]\n      [(= (.-length char) 1) char]\n      [else (error (+ \"Unrecognized char: '\" char \"'\"))])))\n\n(defn read-quote [reader]\n  (list 'quote (read reader)))\n\n(defn read-list [reader first-char]\n  (read-until reader \\)))\n\n(defn read-array [reader first-char]\n  (read-until reader \\]))\n\n(defn read-struct [reader first-char]\n  (list 'dict (spread (read-until reader \\}))))\n\n(defn read-unmatched-delimiter [reader first-char]\n  (error (concat \"Unmatched delimiter: \" first-char)))\n\n(defn read-string [reader first-char]\n  (loop [string \"\"]\n    (let [part (take-until reader (fn [ch] (or (= ch \\\")\n                                               (= ch \\\\))))\n          string2 (concat string part)\n          char (read-char reader)]\n      (cond\n        [(nil? char) (error \"Unexpected EOF while reading string\")]\n        [(= char \\\") string2]\n        [(= char \\\\)\n         (let [char (read-char reader)\n               escaped-char (cond\n                              [(nil? char) (error \"Unexpected EOF while reading character escape\")]\n                              [(= char \\\") char]\n                              [(= char \\\\) char]\n                              [(= char \\/) char]\n                              [(= char \\n) \\newline]\n                              [(= char \\t) \\tab]\n                              [(= char \\r) \\return]\n                              [(= char \\u) (read-unicode-char reader)]\n                              [else (concat (error \"Unrecognized character escape\" char))])]\n           (recur (concat string2 escaped-char)))]))))\n\n(defn read-unicode-char [reader]\n  (let [a (read-char reader),\n        b (read-char reader),\n        c (read-char reader),\n        d (read-char reader)]\n    (.fromCharCode js/String (js/parseInt (+ a b c d)))))\n\n(hash-map-set! reader-macros \\' read-quote)\n(hash-map-set! reader-macros \\\\ read-character)\n(hash-map-set! reader-macros \\\" read-string)\n(hash-map-set! reader-macros \\( read-list)\n(hash-map-set! reader-macros \\) read-unmatched-delimiter)\n(hash-map-set! reader-macros \\[ read-array)\n(hash-map-set! reader-macros \\] read-unmatched-delimiter)\n(hash-map-set! reader-macros \\{ read-struct)\n(hash-map-set! reader-macros \\} read-unmatched-delimiter)\n\n(defn read-until [reader end-char]\n  (loop [results (list)]\n    (skip-whitespace reader)\n    (let [char (peek-char reader)]\n      (cond\n        [(nil? char) (error (+ \"Unexpected EOF, expected: \" end-char))]\n        [(= char end-char)\n         (read-char reader)\n         results]\n        [else (recur (append results (read-syntax reader)))]))))\n\n(defn read [reader]\n  (skip-whitespace reader)\n  (let [c (peek-char reader)]\n    (cond\n      [(char-digit? c) (read-number reader)]\n      [(char-macro? c)\n       (let [macro (hash-map-get reader-macros c)]\n         (read-char reader)\n         (macro reader c))]\n      [else (parse-token (read-token reader))])))\n\n(defn read-syntax [reader]\n  (let [start-pos (reader-pos reader),\n        form (read reader),\n        end-pos (reader-pos reader)]\n    (if (not-nil? form)\n      (meta-set! form {loc: {source: (.-input reader),\n                             start: start-pos,\n                             end: end-pos}}))\n    form))\n\n(defn read-many [reader]\n  (loop [results (list)]\n    (skip-whitespace reader)\n    (if (has-more? reader)\n      (recur (append results (read-syntax reader)))\n      results)))\n\n(defn string->expr [str]\n  (read-syntax (make-string-reader str)))\n\n(defn string->exprs [str]\n  (read-many (make-string-reader str)))\n; -*- mode: Clojure -*-\n\n(def js-keywords (set \"var\" \"let\" \"const\"))\n\n(def emit-specials (hash-map))\n\n;; Predicates\n\n(defn field-access? [form]\n  (and (symbol? form)\n       (string-prefix? (symbol->string form) \".-\")))\n\n(defn method-call? [form]\n  (and (symbol? form)\n       (string-prefix? (symbol->string form) \".\")))\n\n(defn special? [form]\n  (and (symbol? form)\n       (contains-key? emit-specials form)))\n\n(defn js-keyword? [ident]\n  (set-contains? js-keywords ident))\n\n(defn expression? [node]\n  (let [type (.-type node)]\n    (or (= type \"Literal\")\n        (= type \"Identifier\")\n        (string-suffix? type \"Expression\")\n        (string-suffix? type \"Element\"))))\n\n;; Environment\n\n(defn compiler-error [form msg]\n  (if (and (meta form) (.-loc (meta form)))\n    (let [loc (.-loc (meta form)),\n          line-index (- (.-line (.-start loc)) 1),\n          after-line-index (+ line-index 1),\n          before-line-index (- line-index 1),\n          lines (.split (.-source loc) \\newline),\n          line (js/index lines line-index),\n          after-line (js/index lines after-line-index),\n          before-line (js/index lines before-line-index),\n          col (.-column (.-start loc)),\n          caret-line (concat (string-repeat \" \" col) \"^\")]\n      (error (+ msg \"\\n\\n\" before-line \"\\n\" line \"\\n\" caret-line \"\\n\" after-line)))\n    (error msg)))\n\n(defn make-env []\n  {variables: (hash-map),\n   is-loop: false})\n\n(defn child-env [env]\n  {variables: (hash-map-copy (.-variables env))\n   loop-variables: (if (not-nil? (.-loopVariables env))\n                     (array-copy (.-loopVariables env))),\n   is-loop: false})\n\n(defn recur-env [env]\n  {variables: (hash-map-copy (.-variables env))\n   loop-variables: (js/array),\n   is-loop: true})\n\n(defn replace-special-chars [ident]\n  (.replace (.replace (.replace (.replace ident \"!\" \"\")\n                                \"->\" \"-to-\")\n                      (regex \"^((contains|has).*)\\\\?$\") \"$1\")\n            (regex \"^(.*)\\\\?$\") \"is-$1\"))\n\n(defn kebabcase->camelcase [ident]\n  (.replace (replace-special-chars ident)\n            (regex \"[-_]([a-zA-Z])\" \"g\")\n            (fn [match p1] (.toUpperCase p1))))\n\n(defn sanitize-js-keywords [ident]\n  (if (js-keyword? ident)\n    (concat ident \"$\")\n    ident))\n\n(defn symbol->ident [symbol]\n  (cond\n    [(= symbol 'Symbol) \"LispSymbol\"]\n    [else (sanitize-js-keywords (kebabcase->camelcase (symbol->string symbol)))]))\n\n(defn define-variable [env symbol]\n  (let [variables (.-variables env)]\n    (if (not (contains-key? variables symbol))\n      (hash-map-set! variables symbol (symbol->ident symbol)))\n    (if (.-isLoop env)\n      (.push (.-loopVariables env) symbol))\n    (resolve-var env symbol)))\n\n(defn define-function [env symbol]\n  (let [variables (.-variables env)]\n    (if (not (contains-key? variables symbol))\n      (hash-map-set! variables symbol (symbol->ident symbol)))\n    (resolve-var env symbol)))\n\n(defn resolve-var [env symbol]\n  (let [variables (.-variables env),\n        string (symbol->string symbol),\n        loc (if (meta symbol) (.-loc (meta symbol)))]\n    (if (string-prefix? string \"js/\")\n      {type: \"Identifier\",\n       name: (.substring string 3),\n       originalName: string,\n       loc: loc}\n      (if (not (contains-key? variables symbol))\n        (compiler-error symbol (+ \"Symbol not found: \" string))\n        {type: \"Identifier\",\n         name: (hash-map-get variables symbol),\n         originalName: (symbol->string symbol),\n         loc: loc}))))\n\n;; AST Transformation\n\n(defn statement->iife [node]\n  {type: \"CallExpression\",\n   callee: {type: \"ArrowFunctionExpression\",\n            id: nil,\n            params: (js/array),\n            body: {type: \"BlockStatement\",\n                   body: (js/array (statement->return node)),\n                   loc: (.-loc node)}},\n   arguments: (js/array)})\n\n(defn statement->expression [node]\n  (statement->iife node))\n\n(defn statements->return [nodes]\n  (if (empty? nodes)\n    (js/array {:type \"ReturnStatement\",\n               :argument nil})\n    (map-last nodes nil statement->return)))\n\n(defn statement->return [node]\n  (let [type (.-type node)]\n    (cond\n      [(= type \"ReturnStatement\") node]\n      [(= type \"ForOfStatement\") node]\n      [(= type \"ContinueStatement\") node]\n      [(= type \"ThrowStatement\") node]\n      [(= type \"ExpressionStatement\")\n       {type: \"ReturnStatement\",\n        argument: (.-expression node),\n        loc: (.-loc node)}]\n      [(= type \"BlockStatement\")\n       {type: \"BlockStatement\",\n        body: (statements->return (.-body node)),\n        loc: (.-loc node)}]\n      [(= type \"WhileStatement\")\n       {type: \"WhileStatement\",\n        test: (.-test node),\n        body: (statement->return (.-body node)),\n        loc: (.-loc node)}]\n      [(= type \"IfStatement\")\n       {type: \"IfStatement\",\n        test: (.-test node),\n        consequent: (statement->return (.-consequent node)),\n        alternate: (if (.-alternate node)\n                       (statement->return (.-alternate node))\n                       nil),\n        loc: (.-loc node)}]\n      [else (error (concat \"Unsupported return statement: \" type))])))\n\n;; AST Generation of specific types\n\n(defn emit-return-last [env forms]\n  (map-last forms (fn [form] (emit-statement env form))\n                  (fn [form] (emit-return-statement env form))))\n\n(defn emit-return-block [env forms]\n  {type: \"BlockStatement\",\n   body: (emit-return-last env forms)})\n\n(defn emit-return-statement [env form]\n  (let [node (emit env form)]\n    (if (expression? node)\n      {type: \"ReturnStatement\",\n       argument: node,\n       loc: (.-loc node)}\n      (statement->return node))))\n\n(defn emit-statements [env forms]\n  (map forms (fn [form] (emit-statement env form))))\n\n(defn emit-statement [env form]\n  (let [node (emit env form)]\n    (if (expression? node)\n      {type: \"ExpressionStatement\",\n       expression: node,\n       loc: (.-loc node)}\n      node)))\n\n(defn emit-expressions [env forms]\n  (map forms (fn [form] (emit-expression env form))))\n\n(defn emit-expression [env form]\n  (let [node (emit env form)]\n    (if (expression? node)\n      node\n      (statement->expression node))))\n\n(defn emit-patterns [env forms]\n  (map forms (fn [form] (emit-pattern env form))))\n\n(defn emit-pattern [env form]\n  (cond\n    [(symbol? form)\n     (define-variable env form)]\n    [(tagged-list? form 'spread)\n     {type: \"RestElement\",\n      argument: (define-variable env (second form)),\n      loc: (.-loc (meta form))}]\n    [(list? form)\n     {type: \"ArrayPattern\",\n      elements: (emit-patterns env form)}]\n    [else (compiler-error form \"Unrecognized pattern\")]))\n\n(defn emit-block [env forms]\n  (if (single? forms)\n    (emit-statement env (first forms))\n    {type: \"BlockStatement\",\n     body: (emit-statements env forms)}))\n\n;; AST Generation\n\n(defn emit-module [forms]\n  (let [env (make-env)]\n    (for [form forms]\n      (if (tagged-list? form 'defn)\n        (define-variable env (second form))))\n    {type: \"Program\",\n     body: (emit-statements env forms)}))\n\n(defn emit [env form]\n  (cond\n    [(symbol? form) (emit-var env form)]\n    [(list? form) (emit-list env form)]\n    [else (emit-literal env form)]))\n\n(defn emit-literal [env form]\n  (cond\n    [(js/=== form js/undefined) (error \"Undefined!\")]\n    [(keyword? form) (emit env (list 'string->keyword (keyword->string form)))]\n    [else {type: \"Literal\",\n           value: (unbox form),\n           loc: (if (and (not-nil? form) (meta form)) (.-loc (meta form)))}]))\n\n(defn emit-var [env symbol]\n  (resolve-var env symbol))\n\n(defn emit-list [env form]\n  (let [loc (if (meta form) (.-loc (meta form))),\n        callee (first form),\n        args (skip1 form)]\n    (cond\n      [(field-access? callee) (emit-field env loc callee args)]\n      [(method-call? callee) (emit-methodcall env loc callee args)]\n      [(special? callee) ((hash-map-get emit-specials callee) env loc args)]\n      [else (emit-funcall env loc callee args)])))\n\n(defn emit-field [env loc callee args]\n  (let [field-name (.substring (symbol->string callee) 2)\n        obj (first args)]\n    {type: \"MemberExpression\",\n     object: (emit-expression env obj),\n     property: {type: \"Identifier\",\n                name: field-name,\n                loc: (.-loc (meta callee))},\n     computed: false,\n     loc: loc}))\n\n(defn emit-methodcall [env loc callee args]\n  (let [method-name (.substring (symbol->string callee) 1)\n        obj (first args)\n        method-args (skip1 args)]\n    {type: \"CallExpression\",\n     callee: {type: \"MemberExpression\",\n              object: (emit-expression env obj),\n              property: {type: \"Identifier\",\n                         name: method-name,\n                         loc: (.-loc (meta callee))},\n              computed: false},\n     arguments: (emit-expressions env method-args),\n     loc: loc}))\n\n(defn emit-funcall [env loc callee args]\n  {type: \"CallExpression\",\n   callee: (emit-expression env callee),\n   arguments: (emit-expressions env args),\n   loc: loc})\n\n(defn emit-defn [env loc args]\n  (let [ident (define-function env (first args))\n        params (second args)\n        rest (skip2 args)\n        docs (if (and (string? (first rest))\n                      (not-empty? (skip1 rest)))\n                 (first rest))\n        body (if docs (skip1 rest) rest)\n        func-env (child-env env)]\n    {type: \"FunctionDeclaration\",\n     id: ident,\n     params: (emit-patterns func-env params),\n     body: (emit-return-block func-env body),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'defn emit-defn)\n\n(defn emit-defgen [env loc args]\n  (let [ident (define-function env (first args))\n        params (second args)\n        rest (skip2 args)\n        docs (if (and (string? (first rest))\n                      (not-empty? (skip1 rest)))\n                 (first rest))\n        body (if docs (skip1 rest) rest)\n        func-env (child-env env)]\n    {type: \"FunctionDeclaration\",\n     id: ident,\n     params: (emit-patterns func-env params),\n     body: (emit-return-block func-env body),\n     generator: true,\n     loc: loc}))\n\n(hash-map-set! emit-specials 'defgen emit-defgen)\n\n(defn emit-return [env loc args]\n  {type: \"ReturnStatement\",\n   argument: (if (not-empty? args) (emit-expression env (first args))),\n   loc: loc})\n\n(hash-map-set! emit-specials 'return emit-return)\n\n(defn emit-set [env loc args]\n  (let [setter (first args)\n        value (second args)]\n    (cond\n      [(symbol? setter) (emit-set-var env loc setter value)]\n      [(list? setter) (emit-setter env loc setter value)]\n      [else (error (concat \"Invalid setter: \" (repr setter)))])))\n\n(defn emit-setter [env loc setter value]\n  (let [callee (first setter)\n        args (skip1 setter)]\n    (cond\n      [(field-access? callee) (emit-set-field env loc callee args value)]\n      [(= callee 'js/index) (emit-set-index env loc args value)]\n      [else (error (concat \"Invalid setter: \" (repr setter)))])))\n\n(defn emit-set-var [env loc symbol value]\n  {type: \"AssignmentExpression\",\n   operator: \"=\",\n   left: (resolve-var env symbol),\n   right: (emit-expression env value),\n   loc: loc})\n\n(defn emit-set-field [env loc symbol args value]\n  (let [field-name (.substring (symbol->string symbol) 2)\n        obj (first args)]\n    {type: \"AssignmentExpression\",\n     operator: \"=\",\n     left: {type: \"MemberExpression\",\n            object: (emit-expression env obj),\n            property: {type: \"Identifier\",\n                       name: field-name,\n                       loc: (.-loc (meta symbol))},\n            computed: false},\n     right: (emit-expression env value),\n     loc: loc}))\n\n(defn emit-set-index [env loc args value]\n  (let [obj (first args)\n        index (second args)]\n    {type: \"AssignmentExpression\",\n     operator: \"=\",\n     left: {type: \"MemberExpression\",\n            object: (emit-expression env obj),\n            property: (emit-expression env index),\n            computed: true},\n     right: (emit-expression env value),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'set! emit-set)\n\n(defn emit-bin-op [op]\n  (fn [env loc args]\n    (if (empty? args)\n      (error \"Empty operator expression\"))\n    (.reduce (emit-expressions env args)\n            (fn [acc, arg]\n              {type: \"BinaryExpression\",\n               operator: op,\n               left: acc,\n               right: arg,\n               loc: loc}))))\n\n(hash-map-set! emit-specials 'and (emit-bin-op \"&&\"))\n(hash-map-set! emit-specials 'or (emit-bin-op \"||\"))\n(hash-map-set! emit-specials 'js/and (emit-bin-op \"&&\"))\n(hash-map-set! emit-specials 'js/or (emit-bin-op \"||\"))\n(hash-map-set! emit-specials 'js/=== (emit-bin-op \"===\"))\n(hash-map-set! emit-specials 'js/!== (emit-bin-op \"!==\"))\n(hash-map-set! emit-specials 'js/== (emit-bin-op \"==\"))\n(hash-map-set! emit-specials 'js/!= (emit-bin-op \"!=\"))\n(hash-map-set! emit-specials '= (emit-bin-op \"===\"))\n(hash-map-set! emit-specials '!= (emit-bin-op \"!==\"))\n(hash-map-set! emit-specials '>= (emit-bin-op \">=\"))\n(hash-map-set! emit-specials '<= (emit-bin-op \"<=\"))\n(hash-map-set! emit-specials '> (emit-bin-op \">\"))\n(hash-map-set! emit-specials '< (emit-bin-op \"<\"))\n(hash-map-set! emit-specials '+ (emit-bin-op \"+\"))\n(hash-map-set! emit-specials '- (emit-bin-op \"-\"))\n(hash-map-set! emit-specials 'mod (emit-bin-op \"%\"))\n(hash-map-set! emit-specials 'js/instanceof (emit-bin-op \"instanceof\"))\n\n(defn emit-spread [env loc args]\n  {type: \"SpreadElement\",\n   argument: (emit-expression env (first args)),\n   loc: loc})\n\n(hash-map-set! emit-specials 'spread emit-spread)\n\n(defn emit-array [env loc args]\n  {type: \"ArrayExpression\",\n   elements: (emit-expressions env args),\n   loc: loc})\n\n(hash-map-set! emit-specials 'js/array emit-array)\n\n(defn emit-fn [env loc args]\n  (let [params (first args)\n        body (skip1 args)\n        func-env (child-env env)]\n    {type: \"ArrowFunctionExpression\",\n     id: nil,\n     params: (emit-patterns func-env params),\n     body: (emit-return-block func-env body),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'fn emit-fn)\n\n(defn emit-if [env loc args]\n  (let [test (first args)\n        if-true (second args)\n        if-false (skip2 args)]\n    {type: \"IfStatement\",\n     test: (emit-expression env test),\n     consequent: (emit-statement env if-true),\n     alternate: (if (not-nil? if-false) (emit-block env if-false)),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'if emit-if)\n\n(defn emit-for [env loc args]\n  (let [var (first (first args))\n        value (second (first args))\n        body (skip1 args)\n        for-env (child-env env)]\n    {type: \"ForOfStatement\",\n     left: (emit-pattern for-env var),\n     right: (emit-expression for-env value),\n     body: (emit-block for-env body),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'for emit-for)\n\n(defn emit-def [env loc args]\n  {type: \"VariableDeclaration\",\n   kind: \"let\",\n   declarations: (js/array {type: \"VariableDeclarator\",\n                            id: (define-variable env (first args)),\n                            init: (emit-expression env (second args)),\n                            loc: loc}),\n   loc: loc})\n\n(hash-map-set! emit-specials 'def emit-def)\n\n(defn emit-vars [env vars]\n  {type: \"VariableDeclaration\",\n   kind: \"let\",\n   declarations: (map (.from js/Array (grouped vars 2))\n                      (fn [pair]\n                        {type: \"VariableDeclarator\",\n                        id: (define-variable env (first pair)),\n                        init: (emit-expression env (second pair))})),\n   loc: (.-loc (meta vars))})\n\n(defn emit-let [env loc args]\n  (let [vars (first args)\n        body (skip1 args)\n        let-env (child-env env)]\n    {type: \"BlockStatement\",\n     body: (js/array (emit-vars let-env vars) (spread (emit-statements let-env body))),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'let emit-let)\n\n(defn emit-cond [env loc args]\n  (defn emit-branch [args]\n    (let [expr (first args),\n          rest (skip1 args),\n          test (first expr),\n          body (skip1 expr)]\n      (if (= test 'else)\n        (emit-block env body)\n        {type: \"IfStatement\",\n         test: (emit-expression env test),\n         consequent: (emit-block env body),\n         alternate: (if (not-empty? rest) (emit-branch rest))})))\n  (emit-branch args))\n\n(hash-map-set! emit-specials 'cond emit-cond)\n\n(defn emit-loop [env loc args]\n  (let [vars (first args)\n        body (skip1 args)\n        loop-env (recur-env env)]\n    (if (empty? vars)\n      {type: \"WhileStatement\",\n       test: (emit-literal loop-env true),\n       body: (emit-return-block loop-env body)}\n      {type: \"BlockStatement\",\n       body: (js/array (emit-vars loop-env vars)\n                       {type: \"WhileStatement\",\n                        test: (emit-literal loop-env true),\n                        body: (emit-return-block loop-env body)})})))\n\n(hash-map-set! emit-specials 'loop emit-loop)\n\n(defn emit-do [env loc args]\n  {type: \"BlockStatement\",\n   body: (emit-statements env args),\n   loc: loc})\n\n(hash-map-set! emit-specials 'do emit-do)\n\n(defn emit-yield [env loc args]\n  {type: \"YieldExpression\",\n   argument: (emit-expression env (first args)),\n   loc: loc})\n\n(hash-map-set! emit-specials 'yield emit-yield)\n\n(defn emit-recur [env loc args]\n  (if (!= (.-length (.-loopVariables env)) (.-length args))\n    (error (+ \"Recur with not enough args\" (.-length (.-loopVariables env)) (.-length args))))\n  (if (empty? args)\n    {type: \"ContinueStatement\",\n     loc: loc}\n    {type: \"BlockStatement\",\n    body: (js/array (spread (map (zip (.-loopVariables env) args)\n                                  (fn [pair]\n                                    {type: \"ExpressionStatement\",\n                                    expression: {type: \"AssignmentExpression\",\n                                                  operator: \"=\",\n                                                  left: (emit-pattern env (first pair)),\n                                                  right: (emit-expression env (second pair))}})))\n                    {type: \"ContinueStatement\"}),\n    loc: loc}))\n\n(hash-map-set! emit-specials 'recur emit-recur)\n\n(defn emit-dict [env ctx args]\n  {type: \"ObjectExpression\",\n   properties: (map (.from js/Array (grouped args 2))\n                    (fn [pair]\n                      {type: \"Property\",\n                       key: (if (keyword? (first pair))\n                              (emit-literal env (kebabcase->camelcase (keyword->string (first pair))))\n                              (emit-literal env (first pair))),\n                       value: (emit-expression env (second pair))}))})\n\n(hash-map-set! emit-specials 'dict emit-dict)\n\n(defn emit-quote [env loc args]\n  (emit env (knight-quote (first args))))\n\n(defn knight-quote [form]\n  (cond\n    [(symbol? form) (list 'string->symbol (symbol->string form))]\n    [(list? form) (append (list 'js/array) (map knight-quote form))]\n    [else form]))\n\n(hash-map-set! emit-specials 'quote emit-quote)\n\n(defn emit-return [env loc args]\n  {type: \"ReturnStatement\",\n   argument: (if (not-empty? args)\n               (emit-expression env (first args))\n               nil),\n   loc: loc})\n\n(hash-map-set! emit-specials 'js/return emit-return)\n\n(defn emit-throw [env loc args]\n  {type: \"ThrowStatement\",\n   argument: (emit-expression env (first args)),\n   loc: loc})\n\n(hash-map-set! emit-specials 'js/throw emit-throw)\n\n(defn emit-new [env loc args]\n  {type: \"NewExpression\",\n   callee: (emit-expression env (first args)),\n   arguments: (emit-expressions env (skip1 args)),\n   loc: loc})\n\n(hash-map-set! emit-specials 'js/new emit-new)\n\n(defn emit-index [env ctx args]\n  (let [obj (first args)\n        index (second args)]\n    {type: \"MemberExpression\",\n     object: (emit-expression env obj),\n     property: (emit-expression env index),\n     computed: true}))\n\n(hash-map-set! emit-specials 'js/index emit-index)\n; -*- mode: Clojure -*-\n(js/require \"source-map-support/register\")\n\n(def fs (js/require \"fs\"))\n(def escodegen (js/require \"escodegen\"))\n(def terser (js/require \"terser\"))\n(def program (.-program (js/require \"commander\")))\n\n(.option program \"-o, --output <filename>\" \"Output JS filename\")\n(.option program \"-m, --map\" \"Generate source maps\")\n\n(.parse program (.-argv js/process))\n\n(let [output-filename (.-output program),\n      source-map-filename (if (.-map program) (if output-filename (+ output-filename \".map\") \"inline\")),\n      code (.readFileSync fs 0 \"utf-8\"),\n      forms (string->exprs code),\n      ast (emit-module forms),\n      output (.generate escodegen ast {sourceMap: \"stdin\", sourceMapWithCode: true, sourceContent: code}),\n      source-map (.toString (.-map output)),\n      minified (.minify terser (.-code output) {toplevel: true,\n                                                sourceMap: (if source-map-filename\n                                                             {content: source-map, url: source-map-filename})})]\n  (if (.-error minified)\n    (.error js/console (.-error minified))\n    (if output-filename\n      (do\n        (.writeFileSync fs output-filename (.-code minified))\n        (if (and source-map-filename (!= source-map-filename \"inline\"))\n          (.writeFileSync fs source-map-filename (.toString (.-map minified)))))\n      (println (.-code minified)))))\n"]}