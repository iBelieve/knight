{"version":3,"sources":["stdin"],"names":["hash-map","js/Map","hash-map-set!","map","key","value","set","list","items","string->symbol","string","not","contains-key?","interned-symbols","Symbol","hash-map-get","has","name","js/this","get","read","reader","pos","skip-whitespace","c","peek-char","char-digit?","read-number","char-macro?","macro","reader-macros","read-char","token","read-token","string-prefix?","string-suffix?","substring","length","interned-keywords","Keyword","string->keyword","take-while","char","char-whitespace?","take-until","predicate","start-index","index","input-length","input","line","column","offset","not-nil?","includes","string-contains?","js/parseFloat","js/parseInt","concat","a","b","prefix","startsWith","endsWith","error","msg","js/Error","nil?","read-unicode-char","d","js/String","fromCharCode","read-until","end-char","start-pos","has-indent-error","start-line","start-indent","results","last-pos","reader-pos","indent","reader-indent-warning","reader-unterminated-error","append","read-syntax","indentWarnings","push","warning","seq","w","startIndex","find","js/console","marked-line","line-index","before-line-index","after-line-index","lines","split","before-line","after-line","caret-line","string-repeat","line-num","before-line-num","after-line-num","max-line-num-width","values","js/Math","max","string-pad-start","str","count","repeat","toString","width","filler","padStart","form","end-pos","meta","symbol-meta","meta-set!","read-unmatched-delimiter","first-char","first","symbol->ident","symbol","ident","set-contains?","js-keywords","js-keyword?","kebabcase->camelcase","symbol->string","replace","regex","replace-special-chars","match","p1","toUpperCase","flags","js/RegExp","second","skip2","slice","string?","not-empty?","skip1","child-env","env","hash-map-copy","variables","loopVariables","functions","functionNodes","define-function","func","symbol?","resolve-var","function-nodes","loc","func-env","emit-patterns","params","emit-return-block","body","generator","compile-function","compiler-error","js/Array","from","keys","forms","emit-pattern","array","define-variable","tag","list?","isLoop","isArray","source","start","emit-return-last","filter-not-nil","map-last","emit-statement","node","emit","expression?","statement->return","emit-return-statement","filter","last-func","item","emit-var","callee","args","field-access?","field-name","obj","emit-expression","emit-field","method-call?","method-name","method-args","emit-expressions","emit-methodcall","emit-specials","special?","emit-funcall","emit-list","emit-literal","statement->iife","statement->expression","type","expression","statements->return","test","consequent","alternate","nodes","empty?","map-not-nil","js/undefined","keyword?","keyword->string","js/Number","number?","neg","unbox","keyword","valueOf","repr","js/JSON","stringify","emit-bin-op","op","reduce","acc","arg","emit-block","single?","emit-statements","emit-vars","vars","grouped","pair","i","zip","arrays","_","knight-quote","has-more?","js/Symbol","string2","ch","escaped-char","js/Set","rest","docs","setter","emit-set-var","emit-set-field","emit-set-index","emit-setter","if-true","if-false","var","for-env","let-env","emit-cond","expr","loop-env","recur-env","ctx","js/require","fs","path","escodegen","terser","program","option","parse","js/process","argv","output-filename","output","source-map-filename","basename","code","readFileSync","ast","emit-module","read-many","make-string-reader","generate","source-map","minified","minify","writeFileSync","log","println"],"mappings":"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","sourcesContent":["; -*- mode: Clojure -*-\n\n(defn Symbol [name]\n  (set! (.-name js/this) name)\n  (js/return))\n\n(defn Keyword [name]\n  (set! (.-name js/this) name)\n  (js/return))\n\n(defn true? [value]\n  (js/=== value true))\n\n(defn false? [value]\n  (js/=== value false))\n\n(defn truthy? [value]\n  \"A value is considered truthy if it is not false and not nil (i.e., not falsy)\"\n  (js/and (js/!== value false) (js/!= value nil)))\n\n(defn falsy? [value]\n  \"A value is considered falsy if it is false or nil\"\n  (js/or (js/=== value false) (js/== value nil)))\n\n(defn not [value]\n  (js/or (js/=== value false) (js/== value nil)))\n\n(defn nil? [value]\n  (js/== value nil))\n\n(defn not-nil? [value]\n  (js/!= value nil))\n\n(defn symbol? [value]\n  (js/instanceof value Symbol))\n\n(defn keyword? [value]\n  (js/instanceof value Keyword))\n\n(defn bool? [value]\n  (js/or (js/=== (js/typeof value) \"boolean\")\n         (js/instanceof value js/Boolean)))\n\n(defn number? [value]\n  (js/or (js/=== (js/typeof value) \"number\")\n         (js/instanceof value js/Number)))\n\n(defn positive? [value]\n  (and (number? value)\n       (> value 0)))\n\n(defn negative? [value]\n  (and (number? value)\n       (< value 0)))\n\n(defn neg [value]\n  (* -1 value))\n\n(defn char? [value]\n  (js/and (js/or (js/=== (js/typeof value) \"string\")\n                 (js/instanceof value js/String))\n          (js/=== (.-length value) 1)))\n\n(defn string? [value]\n  (js/or (js/=== (js/typeof value) \"string\")\n         (js/instanceof value js/String)))\n\n(defn list? [value]\n  (.isArray js/Array value))\n\n(defn empty? [value]\n  (js/=== (.-length value) 0))\n\n(defn single? [list]\n  (and (list? list)\n       (= (.-length list) 1)))\n\n(defn not-empty? [value]\n  (and (not-nil? value)\n       (> (.-length value) 0)))\n\n(defn list [(spread items)]\n  (js/array (spread items)))\n\n(defn map [array func]\n  (.map array func))\n\n(defn map-not-nil [seq func]\n  (filter-not-nil (map seq func)))\n\n(defn map-last [array func last-func]\n  (.map array\n        (fn [item index]\n          (if (= index (- (.-length array) 1))\n            (last-func item)\n            (if (nil? func)\n              item\n              (func item))))))\n\n(defn find-first [seq predicate]\n  (.find seq predicate))\n\n(defn filter [seq predicate]\n  (.filter seq predicate))\n\n(defn filter-not-nil [seq]\n  (filter seq (fn [value] (not-nil? value))))\n\n\n(defn append [list (spread items)]\n  (js/array (spread list) (spread items)))\n\n(defn concat [a b]\n  (+ a b))\n\n(defn string-contains? [string substring]\n  (.includes string substring))\n\n(defn string-prefix? [string prefix]\n  (.startsWith string prefix))\n\n(defn string-suffix? [string prefix]\n  (.endsWith string prefix))\n\n(defn string-join [string sep]\n  (.join string sep))\n\n; (defn parse-float [string]\n;   (js/parseFloat string))\n\n; (defn parse-int [string]\n;   (js/parseInt string))\n\n(defn println [(spread args)]\n  (.log js/console (spread args)))\n\n(defn print [(spread args)]\n  (for [arg args]\n    (.write (.-stdout js/process) arg)))\n\n(defn hash-map []\n  (js/new js/Map))\n\n(defn hash-map-get [map key]\n  (.get map key))\n\n(defn hash-map-set! [map key value]\n  (.set map key value))\n\n(defn hash-map-copy [map]\n  (js/new js/Map map))\n\n(defn array-copy [array]\n  (.from js/Array array))\n\n(defn contains-key? [map key]\n  (.has map key))\n\n(def interned-symbols (hash-map))\n(def interned-keywords (hash-map))\n\n(defn string->symbol [string]\n  (if (not (contains-key? interned-symbols string))\n    (hash-map-set! interned-symbols string (js/new Symbol string)))\n  (hash-map-get interned-symbols string))\n\n(defn symbol->string [symbol]\n  (.-name symbol))\n\n(defn keyword->string [keyword]\n  (.-name keyword))\n\n(defn string->keyword [string]\n  (let [substring (if (string-prefix? string \":\")\n                    (.substring string 1)\n                    (if (string-suffix? string \":\")\n                      (.substring string 0 (- (.-length string) 1))\n                      string))]\n    (if (not (contains-key? interned-keywords substring))\n      (hash-map-set! interned-keywords substring (js/new Keyword substring)))\n    (hash-map-get interned-keywords substring)))\n\n(defn first [list]\n  (js/index list 0))\n\n(defn second [list]\n  (js/index list 1))\n\n(defn third [list]\n  (js/index list 2))\n\n(defn fourth [list]\n  (js/index list 3))\n\n(defn skip1 [list]\n  (.slice list 1))\n\n(defn skip2 [list]\n  (.slice list 2))\n\n(defn split-last [seq]\n  (js/array (.slice seq 0 (- (.-length seq) 1))\n            (js/index seq (- (.-length seq) 1))))\n\n(defn regex [str flags]\n  (js/new js/RegExp str flags))\n\n(defn error [msg]\n  (js/throw (js/new js/Error msg)))\n\n(defn tagged-list? [value tag]\n  (and (list? value)\n       (= (first value) tag)))\n\n(defn repr [value]\n  (cond\n    [(nil? value) \"nil\"]\n    [else (.stringify js/JSON value)]))\n\n(defgen grouped [seq count]\n  (loop [i 0]\n    (if (< i (.-length seq))\n      (do\n        (yield (.slice seq i (+ i count)))\n        (recur (+ i count))))))\n\n(defn zip [(spread arrays)]\n  (map (first arrays)\n       (fn [_ index]\n         (map arrays (fn [array] (js/index array index))))))\n\n(defn set [(spread values)]\n  (js/new js/Set values))\n\n(defn set-contains? [set value]\n  (.has set value))\n\n(defn box [value]\n  (cond\n    [(bool? value) (js/new js/Boolean value)]\n    [(number? value) (js/new js/Number value)]\n    [(string? value) (js/new js/String value)]\n    [else value]))\n\n(defn unbox [value]\n  (if (not-nil? value)\n    (.valueOf value)\n    nil))\n\n(def symbol-meta (js/Symbol \"meta\"))\n\n(defn meta [value]\n  (js/index value symbol-meta))\n\n(defn meta-set! [value meta]\n  (set! (js/index value symbol-meta) meta)\n  (js/return))\n\n(defn string-repeat [str count]\n  (.repeat str count))\n\n(defn string-pad-start [string width filler]\n  (.padStart string width filler))\n\n(defn string-pad-end [string width filler]\n  (.padEnd string width filler))\n\n(defn string [value]\n  (if (nil? value)\n    \"nil\"\n    (.toString value)))\n\n(defn max [(spread values)]\n  (.max js/Math (spread values)))\n; -*- mode: Clojure -*-\n\n(defn make-string-reader [string]\n  {input: string,\n   index: 0,\n   line: 1,\n   column: 0,\n   indent-warnings: (js/array)})\n\n(def reader-macros (hash-map))\n\n(defn reader-pos [reader]\n  {line: (.-line reader),\n   column: (.-column reader)})\n\n(defn reader-indent-warning [reader start-index end-char pos]\n  (.push (.-indentWarnings reader) {start-index: start-index, end-char: end-char, pos: pos}))\n\n(defn reader-unterminated-error [reader start-index start-pos end-char]\n  (let [warning (find-first (.-indentWarnings reader) (fn [w] (>= (.-startIndex w) start-index)))]\n    (.error js/console warning)\n    (error (+ \"Unexpected EOF, expected: '\" end-char \"'\\n\\n\"\n              \"Started here:\\n\"\n              (marked-line (.-input reader) start-pos) \"\\n\\n\"\n              \"Based on indent:\\n\"\n              (marked-line (.-input reader) (.-pos warning))))))\n\n(defn read-char [reader]\n  (let [char (js/index (.-input reader) (.-index reader))]\n    (set! (.-index reader) (+ (.-index reader) 1))\n    (if (= char \\newline)\n      (do\n        (set! (.-line reader) (+ (.-line reader) 1))\n        (set! (.-column reader) 0))\n      (set! (.-column reader) (+ (.-column reader) 1)))\n    char))\n\n(defn peek-char [reader offset]\n  (js/index (.-input reader)\n            (if (not-nil? offset)\n                (+ (.-index reader) offset)\n                (.-index reader))))\n\n(defn has-more? [reader]\n  (< (.-index reader) (.-length (.-input reader))))\n\n(defn char-whitespace? [char]\n  (or (= char \\space)\n      (= char \\tab)\n      (= char \\newline)\n      (= char \\,)))\n\n(defn char-digit? [char]\n  (and (>= char \\0)\n       (<= char \\9)))\n\n(defn char-macro? [char]\n  (contains-key? reader-macros char))\n\n(defn take-until [reader predicate]\n  (let [start-index (.-index reader)\n        input-length (.-length (.-input reader))]\n    (loop [index (.-index reader),\n           line (.-line reader),\n           column (.-column reader)]\n      (let [char (js/index (.-input reader) index)]\n        (if (or (>= index input-length)\n                (predicate char))\n          (do\n            (set! (.-index reader) index)\n            (set! (.-line reader) line)\n            (set! (.-column reader) column)\n            (.substring (.-input reader) start-index index))\n          (if (= char \\newline)\n            (recur (+ index 1) (+ line 1) 0)\n            (recur (+ index 1) line (+ column 1))))))))\n\n(defn take-while [reader predicate]\n  (take-until reader (fn [char] (not (predicate char)))))\n\n(defn skip-whitespace [reader]\n  (loop []\n    (take-while reader (fn [char] (char-whitespace? char)))\n    (if (= (peek-char reader) \\;)\n      (do\n        (take-until reader (fn [c] (= c \\newline)))\n        (recur)))))\n\n(defn read-token [reader]\n  (concat (read-char reader)\n          (take-until reader (fn (c) (or (char-whitespace? c) (char-macro? c))))))\n\n(defn parse-token [token]\n  (cond\n    [(= token \"nil\") nil]\n    [(= token \"true\") true]\n    [(= token \"false\") false]\n    [(or (string-prefix? token \":\")\n         (string-suffix? token \":\")) (string->keyword token)]\n    [else (string->symbol token)]))\n\n(defn read-number [reader]\n  (let [string (read-token reader)]\n    (if (string-contains? string \".\")\n      (js/parseFloat string)\n      (js/parseInt string))))\n\n(defn read-character [reader]\n  (let [char (read-token reader)]\n    (cond\n      [(= char \"newline\") \\newline]\n      [(= char \"return\") \\return]\n      [(= char \"tab\") \\tab]\n      [(= char \"space\") \\space]\n      [(= (.-length char) 1) char]\n      [else (error (+ \"Unrecognized char: '\" char \"'\"))])))\n\n(defn read-quote [reader]\n  (list 'quote (read reader)))\n\n(defn read-list [reader first-char pos]\n  (read-until reader \\) pos))\n\n(defn read-array [reader first-char pos]\n  (read-until reader \\] pos))\n\n(defn read-struct [reader first-char pos]\n  (list 'dict (spread (read-until reader \\} pos))))\n\n(defn read-unmatched-delimiter [reader first-char]\n  (error (concat \"Unmatched delimiter: \" first-char)))\n\n(defn read-string [reader first-char]\n  (loop [string \"\"]\n    (let [part (take-until reader (fn [ch] (or (= ch \\\")\n                                               (= ch \\\\))))\n          string2 (concat string part)\n          char (read-char reader)]\n      (cond\n        [(nil? char) (error \"Unexpected EOF while reading string\")]\n        [(= char \\\") string2]\n        [(= char \\\\)\n         (let [char (read-char reader)\n               escaped-char (cond\n                              [(nil? char) (error \"Unexpected EOF while reading character escape\")]\n                              [(= char \\\") char]\n                              [(= char \\\\) char]\n                              [(= char \\/) char]\n                              [(= char \\n) \\newline]\n                              [(= char \\t) \\tab]\n                              [(= char \\r) \\return]\n                              [(= char \\u) (read-unicode-char reader)]\n                              [else (concat (error \"Unrecognized character escape\" char))])]\n           (recur (concat string2 escaped-char)))]))))\n\n(defn read-unicode-char [reader]\n  (let [a (read-char reader),\n        b (read-char reader),\n        c (read-char reader),\n        d (read-char reader)]\n    (.fromCharCode js/String (js/parseInt (+ a b c d)))))\n\n(defn marked-line [input pos]\n  (let [line-index (- (.-line pos) 1),\n        before-line-index (- line-index 1),\n        after-line-index (+ line-index 1),\n        lines (.split input \\newline),\n        line (js/index lines line-index),\n        before-line (or (js/index lines before-line-index) \"\"),\n        after-line (or (js/index lines after-line-index) \"\"),\n        col (.-column pos),\n        caret-line (concat (string-repeat \" \" col) \"^\"),\n        line-num (string (+ line-index 1)),\n        before-line-num (string (+ before-line-index 1)),\n        after-line-num (string (+ after-line-index 1)),\n        max-line-num-width (max (.-length line-num)\n                                (.-length before-line-num)\n                                (.-length after-line-num))]\n    (+ (string-pad-start before-line-num max-line-num-width) \" \" before-line \"\\n\"\n       (string-pad-start line-num max-line-num-width) \" \" line \"\\n\"\n       (string-repeat \" \" max-line-num-width) \" \" caret-line \"\\n\"\n       (string-pad-start after-line-num max-line-num-width) \" \" after-line)))\n\n(defn reader-error [reader pos msg]\n  (error (+ msg \"\\n\\n\" (marked-line (.-input reader) pos))))\n\n(defn read-until [reader end-char start-pos]\n  (let [has-indent-error false,\n        start-index (- (.-index reader) 1),\n        start-line (.-line start-pos),\n        start-indent (.-column start-pos)]\n    (loop [results (list)]\n      (if (not has-indent-error)\n        (let [last-pos (reader-pos reader)]\n          (skip-whitespace reader)\n          (let [pos (reader-pos reader),\n                line (.-line pos),\n                indent (.-column pos)]\n            (if (and (> line start-line) (<= indent start-indent))\n              (do\n                (set! has-indent-error true)\n                (reader-indent-warning reader start-index end-char last-pos))))))\n      (let [char (peek-char reader)]\n        (cond\n          [(nil? char)\n           (reader-unterminated-error reader start-index start-pos end-char)]\n          [(= char end-char)\n           (read-char reader)\n           results]\n          [else (recur (append results (read-syntax reader)))])))))\n\n(defn read [reader pos]\n  (skip-whitespace reader)\n  (let [c (peek-char reader)]\n    (cond\n      [(char-digit? c) (read-number reader)]\n      [(char-macro? c)\n       (let [macro (hash-map-get reader-macros c)]\n         (read-char reader)\n         (macro reader c pos))]\n      [(and (or (= c \\+) (= c \\-))\n            (char-digit? (peek-char reader 1)))\n       (read-number reader)]\n      [else (parse-token (read-token reader))])))\n\n(defn read-syntax [reader]\n  (let [start-pos (reader-pos reader),\n        form (read reader start-pos),\n        end-pos (reader-pos reader)]\n    (if (not-nil? form)\n      (meta-set! form {loc: {source: (.-input reader),\n                             start: start-pos,\n                             end: end-pos}}))\n    form))\n\n(defn read-many [reader]\n  (loop [results (list)]\n    (skip-whitespace reader)\n    (if (has-more? reader)\n      (recur (append results (read-syntax reader)))\n      results)))\n\n(defn string->expr [str]\n  (read-syntax (make-string-reader str)))\n\n(defn string->exprs [str]\n  (read-many (make-string-reader str)))\n\n(hash-map-set! reader-macros \\' read-quote)\n(hash-map-set! reader-macros \\\\ read-character)\n(hash-map-set! reader-macros \\\" read-string)\n(hash-map-set! reader-macros \\( read-list)\n(hash-map-set! reader-macros \\) read-unmatched-delimiter)\n(hash-map-set! reader-macros \\[ read-array)\n(hash-map-set! reader-macros \\] read-unmatched-delimiter)\n(hash-map-set! reader-macros \\{ read-struct)\n(hash-map-set! reader-macros \\} read-unmatched-delimiter)\n; -*- mode: Clojure -*-\n\n(def js-keywords (set \"var\" \"let\" \"const\"))\n\n(defn compiler-error [form msg]\n  (if (and (meta form) (.-loc (meta form)))\n    (let [loc (.-loc (meta form)),\n          source (.-source loc),\n          pos (.-start loc)]\n      (error (+ msg \"\\n\\n\" (marked-line source pos))))\n    (error msg)))\n\n(defn make-env []\n  {functions: (hash-map),\n   function-nodes: (hash-map),\n   variables: (hash-map),\n   is-loop: false})\n\n(defn child-env [env]\n  {variables: (hash-map-copy (.-variables env))\n   loop-variables: (.-loopVariables env),\n   functions: (.-functions env),\n   function-nodes: (.-functionNodes env),\n   is-loop: false})\n\n(defn recur-env [env]\n  {variables: (hash-map-copy (.-variables env))\n   loop-variables: (js/array),\n   functions: (.-functions env),\n   function-nodes: (.-functionNodes env),\n   is-loop: true})\n\n(defn replace-special-chars [ident]\n  (.replace (.replace (.replace (.replace ident \"!\" \"\")\n                                \"->\" \"-to-\")\n                      (regex \"^((contains|has).*)\\\\?$\") \"$1\")\n            (regex \"^(.*)\\\\?$\") \"is-$1\"))\n\n(defn kebabcase->camelcase [ident]\n  (.replace (replace-special-chars ident)\n            (regex \"[-_]([a-zA-Z])\" \"g\")\n            (fn [match p1] (.toUpperCase p1))))\n\n(defn sanitize-js-keywords [ident]\n  (if (js-keyword? ident)\n    (concat ident \"$\")\n    ident))\n\n(defn symbol->ident [symbol]\n  (cond\n    [(= symbol 'Symbol) \"LispSymbol\"]\n    [else (sanitize-js-keywords (kebabcase->camelcase (symbol->string symbol)))]))\n\n(defn define-variable [env symbol]\n  (let [variables (.-variables env)]\n    (if (not (contains-key? variables symbol))\n      (hash-map-set! variables symbol (symbol->ident symbol)))\n    (if (.-isLoop env)\n      (.push (.-loopVariables env) symbol))\n    (resolve-var env symbol)))\n\n(defn define-function [env name func]\n  (let [functions (.-functions env)]\n    (if (contains-key? functions name)\n      (error (+ \"Function already defined: \" (symbol->string name)))\n      (hash-map-set! functions name func))\n    nil))\n\n(defn resolve-var [env symbol]\n  (let [variables (.-variables env),\n        functions (.-functions env),\n        function-nodes (.-functionNodes env),\n        string (symbol->string symbol),\n        loc (if (meta symbol) (.-loc (meta symbol)))]\n    (cond\n      [(string-prefix? string \"js/\")\n       {type: \"Identifier\",\n        name: (.substring string 3),\n        originalName: string,\n        loc: loc}]\n      [(contains-key? variables symbol)\n       {type: \"Identifier\",\n        name: (hash-map-get variables symbol),\n        originalName: string,\n        loc: loc}]\n      [(contains-key? functions symbol)\n       (if (not (contains-key? function-nodes symbol))\n         (compile-function env (hash-map-get functions symbol)))\n       {type: \"Identifier\",\n        name: (.-ident (hash-map-get functions symbol)),\n        originalName: string,\n        loc: loc}]\n      [else\n       (compiler-error symbol (+ \"Variable or function not found: \" string \" - \"\n                                 (map (.from js/Array (.keys variables)) symbol->string) \" - \"\n                                 (map (.from js/Array (.keys functions)) symbol->string)))])))\n\n(defn compile-function [env func]\n  (let [func-env (child-env env)]\n    (hash-map-set! (.-functionNodes env)\n                   (.-name func) 'placeholder)\n    (hash-map-set! (.-functionNodes env)\n                   (.-name func)\n                   {type: \"FunctionDeclaration\",\n                    id: {type: \"Identifier\",\n                         name: (.-ident func),\n                         originalName: (symbol->string (.-name func)),\n                         loc: (.-loc (meta (.-name func)))},\n                    params: (emit-patterns func-env (.-params func)),\n                    body: (emit-return-block func-env (.-body func)),\n                    generator: (.-generator func),\n                    loc: (.-loc func)})))\n; -*- mode: Clojure -*-\n\n(def emit-specials (hash-map))\n\n;; Predicates\n\n(defn field-access? [form]\n  (and (symbol? form)\n       (string-prefix? (symbol->string form) \".-\")))\n\n(defn method-call? [form]\n  (and (symbol? form)\n       (string-prefix? (symbol->string form) \".\")))\n\n(defn special? [form]\n  (and (symbol? form)\n       (contains-key? emit-specials form)))\n\n(defn js-keyword? [ident]\n  (set-contains? js-keywords ident))\n\n(defn expression? [node]\n  (let [type (.-type node)]\n    (or (= type \"Literal\")\n        (= type \"Identifier\")\n        (string-suffix? type \"Expression\")\n        (string-suffix? type \"Element\"))))\n\n;; AST Transformation\n\n(defn statement->iife [node]\n  {type: \"CallExpression\",\n   callee: {type: \"ArrowFunctionExpression\",\n            id: nil,\n            params: (js/array),\n            body: {type: \"BlockStatement\",\n                   body: (js/array (statement->return node)),\n                   loc: (.-loc node)}},\n   arguments: (js/array)})\n\n(defn statement->expression [node]\n  (statement->iife node))\n\n(defn statements->return [nodes]\n  (if (empty? nodes)\n    (js/array {:type \"ReturnStatement\",\n               :argument nil})\n    (map-last nodes nil statement->return)))\n\n(defn statement->return [node]\n  (let [type (.-type node)]\n    (cond\n      [(= type \"ReturnStatement\") node]\n      [(= type \"ForOfStatement\") node]\n      [(= type \"ContinueStatement\") node]\n      [(= type \"ThrowStatement\") node]\n      [(= type \"ExpressionStatement\")\n       {type: \"ReturnStatement\",\n        argument: (.-expression node),\n        loc: (.-loc node)}]\n      [(= type \"BlockStatement\")\n       {type: \"BlockStatement\",\n        body: (statements->return (.-body node)),\n        loc: (.-loc node)}]\n      [(= type \"WhileStatement\")\n       {type: \"WhileStatement\",\n        test: (.-test node),\n        body: (statement->return (.-body node)),\n        loc: (.-loc node)}]\n      [(= type \"IfStatement\")\n       {type: \"IfStatement\",\n        test: (.-test node),\n        consequent: (statement->return (.-consequent node)),\n        alternate: (if (.-alternate node)\n                       (statement->return (.-alternate node))\n                       nil),\n        loc: (.-loc node)}]\n      [else (error (concat \"Unsupported return statement: \" type))])))\n\n;; AST Generation of specific types\n\n(defn emit-return-last [env forms]\n  (filter-not-nil (map-last forms (fn [form] (emit-statement env form))\n                                  (fn [form] (emit-return-statement env form)))))\n\n(defn emit-return-block [env forms]\n  {type: \"BlockStatement\",\n   body: (emit-return-last env forms)})\n\n(defn emit-return-statement [env form]\n  (let [node (emit env form)]\n    (if (expression? node)\n      {type: \"ReturnStatement\",\n       argument: node,\n       loc: (.-loc node)}\n      (statement->return node))))\n\n(defn emit-statements [env forms]\n  (map-not-nil forms (fn [form] (emit-statement env form))))\n\n(defn emit-statement [env form]\n  (let [node (emit env form)]\n    (cond\n      [(nil? node) node]\n      [(expression? node)\n       {type: \"ExpressionStatement\",\n        expression: node,\n        loc: (.-loc node)}]\n      [else node])))\n\n(defn emit-expressions [env forms]\n  (map-not-nil forms (fn [form] (emit-expression env form))))\n\n(defn emit-expression [env form]\n  (let [node (emit env form)]\n    (cond\n      [(nil? node) node]\n      [(expression? node) node]\n      [else (statement->expression node)])))\n\n(defn emit-patterns [env forms]\n  (map forms (fn [form] (emit-pattern env form))))\n\n(defn emit-pattern [env form]\n  (cond\n    [(symbol? form)\n     (define-variable env form)]\n    [(tagged-list? form 'spread)\n     {type: \"RestElement\",\n      argument: (define-variable env (second form)),\n      loc: (.-loc (meta form))}]\n    [(list? form)\n     {type: \"ArrayPattern\",\n      elements: (emit-patterns env form)}]\n    [else (compiler-error form \"Unrecognized pattern\")]))\n\n(defn emit-block [env forms]\n  (if (single? forms)\n    (emit-statement env (first forms))\n    {type: \"BlockStatement\",\n     body: (emit-statements env forms)}))\n\n;; AST Generation\n\n(defn emit-module [forms]\n  (let [env (make-env),\n        nodes (emit-statements env forms),\n        function-nodes (.-functionNodes env)]\n    {type: \"Program\",\n     body: (js/array (spread (.values function-nodes)) (spread nodes))}))\n\n(defn emit [env form]\n  (cond\n    [(symbol? form) (emit-var env form)]\n    [(list? form) (emit-list env form)]\n    [else (emit-literal env form)]))\n\n(defn emit-literal [env form]\n  (cond\n    [(js/=== form js/undefined) (error \"Undefined!\")]\n    [(keyword? form) (emit env (list 'string->keyword (keyword->string form)))]\n    [(negative? form)\n     {type: \"UnaryExpression\",\n      operator: \"-\",\n      prefix: true,\n      argument: {type: \"Literal\",\n                 value: (neg (unbox form))},\n      loc: (if (and (not-nil? form) (meta form)) (.-loc (meta form)))}]\n    [else {type: \"Literal\",\n           value: (unbox form),\n           loc: (if (and (not-nil? form) (meta form)) (.-loc (meta form)))}]))\n\n(defn emit-var [env symbol]\n  (resolve-var env symbol))\n\n(defn emit-list [env form]\n  (let [loc (if (meta form) (.-loc (meta form))),\n        callee (first form),\n        args (skip1 form)]\n    (cond\n      [(field-access? callee) (emit-field env loc callee args)]\n      [(method-call? callee) (emit-methodcall env loc callee args)]\n      [(special? callee) ((hash-map-get emit-specials callee) env loc args)]\n      [else (emit-funcall env loc callee args)])))\n\n(defn emit-field [env loc callee args]\n  (let [field-name (.substring (symbol->string callee) 2)\n        obj (first args)]\n    {type: \"MemberExpression\",\n     object: (emit-expression env obj),\n     property: {type: \"Identifier\",\n                name: field-name,\n                loc: (.-loc (meta callee))},\n     computed: false,\n     loc: loc}))\n\n(defn emit-methodcall [env loc callee args]\n  (let [method-name (.substring (symbol->string callee) 1)\n        obj (first args)\n        method-args (skip1 args)]\n    {type: \"CallExpression\",\n     callee: {type: \"MemberExpression\",\n              object: (emit-expression env obj),\n              property: {type: \"Identifier\",\n                         name: method-name,\n                         loc: (.-loc (meta callee))},\n              computed: false},\n     arguments: (emit-expressions env method-args),\n     loc: loc}))\n\n(defn emit-funcall [env loc callee args]\n  {type: \"CallExpression\",\n   callee: (emit-expression env callee),\n   arguments: (emit-expressions env args),\n   loc: loc})\n\n(defn emit-defn [env loc args]\n  (let [name (first args)\n        ident (symbol->ident name)\n        params (second args)\n        rest (skip2 args)\n        docs (if (and (string? (first rest))\n                      (not-empty? (skip1 rest)))\n                 (first rest))\n        body (if docs (skip1 rest) rest)\n        func-env (child-env env)]\n    (define-function env name {name: name,\n                               ident: ident,\n                               params: params,\n                               docs: docs,\n                               body: body,\n                               loc: loc,\n                               generator: false})))\n\n(hash-map-set! emit-specials 'defn emit-defn)\n\n(defn emit-defgen [env loc args]\n  (let [name (first args)\n        ident (symbol->ident name)\n        params (second args)\n        rest (skip2 args)\n        docs (if (and (string? (first rest))\n                      (not-empty? (skip1 rest)))\n                 (first rest))\n        body (if docs (skip1 rest) rest)\n        func-env (child-env env)]\n    (define-function env name {name: name,\n                               ident: ident,\n                               params: params,\n                               docs: docs,\n                               body: body,\n                               loc: loc,\n                               generator: true})))\n\n(hash-map-set! emit-specials 'defgen emit-defgen)\n\n(defn emit-set [env loc args]\n  (let [setter (first args)\n        value (second args)]\n    (cond\n      [(symbol? setter) (emit-set-var env loc setter value)]\n      [(list? setter) (emit-setter env loc setter value)]\n      [else (error (concat \"Invalid setter: \" (repr setter)))])))\n\n(defn emit-setter [env loc setter value]\n  (let [callee (first setter)\n        args (skip1 setter)]\n    (cond\n      [(field-access? callee) (emit-set-field env loc callee args value)]\n      [(= callee 'js/index) (emit-set-index env loc args value)]\n      [else (error (concat \"Invalid setter: \" (repr setter)))])))\n\n(defn emit-set-var [env loc symbol value]\n  {type: \"AssignmentExpression\",\n   operator: \"=\",\n   left: (resolve-var env symbol),\n   right: (emit-expression env value),\n   loc: loc})\n\n(defn emit-set-field [env loc symbol args value]\n  (let [field-name (.substring (symbol->string symbol) 2)\n        obj (first args)]\n    {type: \"AssignmentExpression\",\n     operator: \"=\",\n     left: {type: \"MemberExpression\",\n            object: (emit-expression env obj),\n            property: {type: \"Identifier\",\n                       name: field-name,\n                       loc: (.-loc (meta symbol))},\n            computed: false},\n     right: (emit-expression env value),\n     loc: loc}))\n\n(defn emit-set-index [env loc args value]\n  (let [obj (first args)\n        index (second args)]\n    {type: \"AssignmentExpression\",\n     operator: \"=\",\n     left: {type: \"MemberExpression\",\n            object: (emit-expression env obj),\n            property: (emit-expression env index),\n            computed: true},\n     right: (emit-expression env value),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'set! emit-set)\n\n(defn emit-bin-op [op]\n  (fn [env loc args]\n    (if (empty? args)\n      (error \"Empty operator expression\"))\n    (.reduce (emit-expressions env args)\n            (fn [acc, arg]\n              {type: \"BinaryExpression\",\n               operator: op,\n               left: acc,\n               right: arg,\n               loc: loc}))))\n\n(hash-map-set! emit-specials 'and (emit-bin-op \"&&\"))\n(hash-map-set! emit-specials 'or (emit-bin-op \"||\"))\n(hash-map-set! emit-specials 'js/and (emit-bin-op \"&&\"))\n(hash-map-set! emit-specials 'js/or (emit-bin-op \"||\"))\n(hash-map-set! emit-specials 'js/=== (emit-bin-op \"===\"))\n(hash-map-set! emit-specials 'js/!== (emit-bin-op \"!==\"))\n(hash-map-set! emit-specials 'js/== (emit-bin-op \"==\"))\n(hash-map-set! emit-specials 'js/!= (emit-bin-op \"!=\"))\n(hash-map-set! emit-specials '= (emit-bin-op \"===\"))\n(hash-map-set! emit-specials '!= (emit-bin-op \"!==\"))\n(hash-map-set! emit-specials '>= (emit-bin-op \">=\"))\n(hash-map-set! emit-specials '<= (emit-bin-op \"<=\"))\n(hash-map-set! emit-specials '> (emit-bin-op \">\"))\n(hash-map-set! emit-specials '< (emit-bin-op \"<\"))\n(hash-map-set! emit-specials '+ (emit-bin-op \"+\"))\n(hash-map-set! emit-specials '- (emit-bin-op \"-\"))\n(hash-map-set! emit-specials '* (emit-bin-op \"*\"))\n(hash-map-set! emit-specials '/ (emit-bin-op \"/\"))\n(hash-map-set! emit-specials 'mod (emit-bin-op \"%\"))\n(hash-map-set! emit-specials 'js/instanceof (emit-bin-op \"instanceof\"))\n\n(defn emit-spread [env loc args]\n  {type: \"SpreadElement\",\n   argument: (emit-expression env (first args)),\n   loc: loc})\n\n(hash-map-set! emit-specials 'spread emit-spread)\n\n(defn emit-array [env loc args]\n  {type: \"ArrayExpression\",\n   elements: (emit-expressions env args),\n   loc: loc})\n\n(hash-map-set! emit-specials 'js/array emit-array)\n\n(defn emit-fn [env loc args]\n  (let [params (first args)\n        body (skip1 args)\n        func-env (child-env env)]\n    {type: \"ArrowFunctionExpression\",\n     id: nil,\n     params: (emit-patterns func-env params),\n     body: (emit-return-block func-env body),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'fn emit-fn)\n\n(defn emit-if [env loc args]\n  (let [test (first args)\n        if-true (second args)\n        if-false (skip2 args)]\n    {type: \"IfStatement\",\n     test: (emit-expression env test),\n     consequent: (emit-statement env if-true),\n     alternate: (if (not-nil? if-false) (emit-block env if-false)),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'if emit-if)\n\n(defn emit-for [env loc args]\n  (let [var (first (first args))\n        value (second (first args))\n        body (skip1 args)\n        for-env (child-env env)]\n    {type: \"ForOfStatement\",\n     left: (emit-pattern for-env var),\n     right: (emit-expression for-env value),\n     body: (emit-block for-env body),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'for emit-for)\n\n(defn emit-def [env loc args]\n  {type: \"VariableDeclaration\",\n   kind: \"let\",\n   declarations: (js/array {type: \"VariableDeclarator\",\n                            id: (define-variable env (first args)),\n                            init: (emit-expression env (second args)),\n                            loc: loc}),\n   loc: loc})\n\n(hash-map-set! emit-specials 'def emit-def)\n\n(defn emit-vars [env vars]\n  {type: \"VariableDeclaration\",\n   kind: \"let\",\n   declarations: (map (.from js/Array (grouped vars 2))\n                      (fn [pair]\n                        {type: \"VariableDeclarator\",\n                         id: (define-variable env (first pair)),\n                         init: (emit-expression env (second pair))})),\n   loc: (.-loc (meta vars))})\n\n(defn emit-let [env loc args]\n  (let [vars (first args)\n        body (skip1 args)\n        let-env (child-env env)]\n    {type: \"BlockStatement\",\n     body: (js/array (emit-vars let-env vars) (spread (emit-statements let-env body))),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'let emit-let)\n\n(defn emit-cond [env loc args]\n  (let [expr (first args),\n        rest (skip1 args),\n        test (first expr),\n        body (skip1 expr)]\n    (if (= test 'else)\n      (emit-block env body)\n      {type: \"IfStatement\",\n       test: (emit-expression env test),\n       consequent: (emit-block env body),\n       alternate: (if (not-empty? rest) (emit-cond env loc rest))})))\n\n(hash-map-set! emit-specials 'cond emit-cond)\n\n(defn emit-loop [env loc args]\n  (let [vars (first args)\n        body (skip1 args)\n        loop-env (recur-env env)]\n    (if (empty? vars)\n      {type: \"WhileStatement\",\n       test: (emit-literal loop-env true),\n       body: (emit-return-block loop-env body)}\n      {type: \"BlockStatement\",\n       body: (js/array (emit-vars loop-env vars)\n                       {type: \"WhileStatement\",\n                        test: (emit-literal loop-env true),\n                        body: (emit-return-block loop-env body)})})))\n\n(hash-map-set! emit-specials 'loop emit-loop)\n\n(defn emit-do [env loc args]\n  {type: \"BlockStatement\",\n   body: (emit-statements env args),\n   loc: loc})\n\n(hash-map-set! emit-specials 'do emit-do)\n\n(defn emit-yield [env loc args]\n  {type: \"YieldExpression\",\n   argument: (emit-expression env (first args)),\n   loc: loc})\n\n(hash-map-set! emit-specials 'yield emit-yield)\n\n(defn emit-recur [env loc args]\n  (if (!= (.-length (.-loopVariables env)) (.-length args))\n    (error (+ \"Recur with not enough args\" (.-length (.-loopVariables env)) (.-length args))))\n  (if (empty? args)\n    {type: \"ContinueStatement\",\n     loc: loc}\n    {type: \"BlockStatement\",\n     body: (js/array (spread (map (zip (.-loopVariables env) args)\n                                  (fn [pair]\n                                    {type: \"ExpressionStatement\",\n                                     expression: {type: \"AssignmentExpression\",\n                                                  operator: \"=\",\n                                                  left: (emit-pattern env (first pair)),\n                                                  right: (emit-expression env (second pair))}})))\n                    {type: \"ContinueStatement\"}),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'recur emit-recur)\n\n(defn emit-dict [env ctx args]\n  {type: \"ObjectExpression\",\n   properties: (map (.from js/Array (grouped args 2))\n                    (fn [pair]\n                      {type: \"Property\",\n                       key: (if (keyword? (first pair))\n                              (emit-literal env (kebabcase->camelcase (keyword->string (first pair))))\n                              (emit-literal env (first pair))),\n                       value: (emit-expression env (second pair))}))})\n\n(hash-map-set! emit-specials 'dict emit-dict)\n\n(defn emit-quote [env loc args]\n  (emit env (knight-quote (first args))))\n\n(defn knight-quote [form]\n  (cond\n    [(symbol? form) (list 'string->symbol (symbol->string form))]\n    [(list? form) (append (list 'js/array) (map knight-quote form))]\n    [else form]))\n\n(hash-map-set! emit-specials 'quote emit-quote)\n\n(defn emit-return [env loc args]\n  {type: \"ReturnStatement\",\n   argument: (if (not-empty? args)\n               (emit-expression env (first args))\n               nil),\n   loc: loc})\n\n(hash-map-set! emit-specials 'js/return emit-return)\n\n(defn emit-throw [env loc args]\n  {type: \"ThrowStatement\",\n   argument: (emit-expression env (first args)),\n   loc: loc})\n\n(hash-map-set! emit-specials 'js/throw emit-throw)\n\n(defn emit-new [env loc args]\n  {type: \"NewExpression\",\n   callee: (emit-expression env (first args)),\n   arguments: (emit-expressions env (skip1 args)),\n   loc: loc})\n\n(hash-map-set! emit-specials 'js/new emit-new)\n\n(defn emit-index [env ctx args]\n  (let [obj (first args)\n        index (second args)]\n    {type: \"MemberExpression\",\n     object: (emit-expression env obj),\n     property: (emit-expression env index),\n     computed: true}))\n\n(hash-map-set! emit-specials 'js/index emit-index)\n; -*- mode: Clojure -*-\n(js/require \"source-map-support/register\")\n\n(def fs (js/require \"fs\"))\n(def path (js/require \"path\"))\n(def escodegen (js/require \"escodegen\"))\n(def terser (js/require \"terser\"))\n(def program (.-program (js/require \"commander\")))\n\n(.option program \"-o, --output <filename>\" \"Output JS filename\")\n(.option program \"-m, --map\" \"Generate source maps\")\n\n(.parse program (.-argv js/process))\n\n(let [output-filename (.-output program),\n      source-map-filename (if (.-map program) (if output-filename (+ (.basename path output-filename) \".map\") \"inline\")),\n      code (.readFileSync fs 0 \"utf-8\"),\n      forms (string->exprs code),\n      ast (emit-module forms),\n      output (.generate escodegen ast {sourceMap: \"stdin\", sourceMapWithCode: true, sourceContent: code}),\n      source-map (.toString (.-map output)),\n      minified (.minify terser (.-code output) {toplevel: true,\n                                                sourceMap: (if source-map-filename\n                                                             {content: source-map, url: source-map-filename})})]\n  (if (.-error minified)\n    (.error js/console (.-error minified))\n    (if output-filename\n      (do\n        (.writeFileSync fs output-filename (.-code minified))\n        (if (and source-map-filename (!= source-map-filename \"inline\"))\n          (.writeFileSync fs source-map-filename (.toString (.-map minified)))))\n      (println (.-code minified)))))\n"]}