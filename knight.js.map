{"version":3,"sources":["stdin"],"names":["hash-map","js/Map","hash-map-set!","map","key","value","set","list","items","string->symbol","string","not","contains-key?","interned-symbols","Symbol","hash-map-get","has","name","js/this","get","read-syntax","reader","start-pos","reader-pos","form","pos","skip-whitespace","c","peek-char","char-digit?","read-number","char-macro?","macro","reader-macros","read-char","token","read-token","string-prefix?","string-suffix?","substring","length","interned-keywords","Keyword","string->keyword","read","end-pos","not-nil?","meta","symbol-meta","meta-set!","input","line","column","take-while","char","char-whitespace?","take-until","predicate","start-index","index","input-length","offset","includes","string-contains?","js/parseFloat","js/parseInt","concat","a","b","prefix","startsWith","endsWith","expand-syntax-quote","js/Boolean","number?","string?","keyword?","self-evaluating?","symbol?","tagged-list?","second","list?","js/Number","js/String","tag","first","js/Array","isArray","array","func","error","msg","js/Error","nil?","read-unicode-char","d","fromCharCode","read-until","end-char","has-indent-error","start-line","start-indent","results","last-pos","indent","reader-indent-warning","reader-unterminated-error","append","indentWarnings","push","warning","seq","w","startIndex","find","js/console","marked-line","line-index","before-line-index","after-line-index","lines","split","before-line","after-line","caret-line","string-repeat","line-num","before-line-num","after-line-num","max-line-num-width","values","js/Math","max","string-pad-start","str","count","repeat","toString","width","filler","padStart","read-unmatched-delimiter","first-char","symbol->ident","symbol","ident","set-contains?","js-keywords","js-keyword?","kebabcase->camelcase","symbol->string","replace","regex","replace-special-chars","match","p1","toUpperCase","flags","js/RegExp","skip2","slice","not-empty?","skip1","child-env","env","hash-map-copy","variables","loopVariables","functions","functionNodes","define-function","resolve-var","function-nodes","loc","func-env","emit-patterns","params","emit-return-block","body","generator","compile-function","compiler-error","from","keys","forms","emit-pattern","define-variable","isLoop","source","start","emit-return-last","filter-not-nil","map-last","emit-statement","node","emit","expression?","statement->return","emit-return-statement","filter","last-func","item","emit-var","callee","args","field-access?","field-name","obj","emit-expression","emit-field","method-call?","method-name","method-args","emit-expressions","emit-methodcall","emit-specials","special?","emit-funcall","emit-list","emit-literal","statement->iife","statement->expression","type","expression","statements->return","test","consequent","alternate","nodes","empty?","map-not-nil","js/undefined","keyword->string","neg","unbox","keyword","valueOf","repr","js/JSON","stringify","emit-bin-op","op","reduce","acc","arg","emit-block","single?","emit-statements","emit-vars","vars","grouped","pair","i","zip","arrays","_","knight-quote","has-more?","js/Symbol","string2","ch","escaped-char","js/Set","rest","docs","setter","emit-set-var","emit-set-field","emit-set-index","emit-setter","if-true","if-false","var","for-env","let-env","emit-cond","expr","loop-env","recur-env","ctx","js/require","fs","path","escodegen","terser","program","option","parse","js/process","argv","output-filename","output","output-dirname","dirname","source-map-filename","basename","code","readFileSync","ast","emit-module","read-many","make-string-reader","generate","source-map","minified","minify","writeFileSync","join","log","println"],"mappings":"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","sourcesContent":["; -*- mode: Clojure -*-\n\n(defn Symbol [name]\n  (set! (.-name js/this) name)\n  (js/return))\n\n(defn Keyword [name]\n  (set! (.-name js/this) name)\n  (js/return))\n\n(defn true? [value]\n  (js/=== value true))\n\n(defn false? [value]\n  (js/=== value false))\n\n(defn truthy? [value]\n  \"A value is considered truthy if it is not false and not nil (i.e., not falsy)\"\n  (js/and (js/!== value false) (js/!= value nil)))\n\n(defn falsy? [value]\n  \"A value is considered falsy if it is false or nil\"\n  (js/or (js/=== value false) (js/== value nil)))\n\n(defn not [value]\n  (js/or (js/=== value false) (js/== value nil)))\n\n(defn nil? [value]\n  (js/== value nil))\n\n(defn not-nil? [value]\n  (js/!= value nil))\n\n(defn symbol? [value]\n  (js/instanceof value Symbol))\n\n(defn keyword? [value]\n  (js/instanceof value Keyword))\n\n(defn bool? [value]\n  (js/or (js/=== (js/typeof value) \"boolean\")\n         (js/instanceof value js/Boolean)))\n\n(defn number? [value]\n  (js/or (js/=== (js/typeof value) \"number\")\n         (js/instanceof value js/Number)))\n\n(defn positive? [value]\n  (and (number? value)\n       (> value 0)))\n\n(defn negative? [value]\n  (and (number? value)\n       (< value 0)))\n\n(defn neg [value]\n  (* -1 value))\n\n(defn char? [value]\n  (js/and (js/or (js/=== (js/typeof value) \"string\")\n                 (js/instanceof value js/String))\n          (js/=== (.-length value) 1)))\n\n(defn string? [value]\n  (js/or (js/=== (js/typeof value) \"string\")\n         (js/instanceof value js/String)))\n\n(defn list? [value]\n  (.isArray js/Array value))\n\n(defn empty? [value]\n  (js/=== (.-length value) 0))\n\n(defn single? [list]\n  (and (list? list)\n       (= (.-length list) 1)))\n\n(defn not-empty? [value]\n  (and (not-nil? value)\n       (> (.-length value) 0)))\n\n(defn list [&items]\n  (js/array &items))\n\n(defn map [array func]\n  (.map array func))\n\n(defn map-not-nil [seq func]\n  (filter-not-nil (map seq func)))\n\n(defn map-last [array func last-func]\n  (.map array\n        (fn [item index]\n          (if (= index (- (.-length array) 1))\n            (last-func item)\n            (if (nil? func)\n              item\n              (func item))))))\n\n(defn find-first [seq predicate]\n  (.find seq predicate))\n\n(defn filter [seq predicate]\n  (.filter seq predicate))\n\n(defn filter-not-nil [seq]\n  (filter seq (fn [value] (not-nil? value))))\n\n\n(defn append [list &items]\n  (js/array &list &items))\n\n(defn concat [a b]\n  (+ a b))\n\n(defn string-contains? [string substring]\n  (.includes string substring))\n\n(defn string-prefix? [string prefix]\n  (.startsWith string prefix))\n\n(defn string-suffix? [string prefix]\n  (.endsWith string prefix))\n\n(defn string-join [string sep]\n  (.join string sep))\n\n; (defn parse-float [string]\n;   (js/parseFloat string))\n\n; (defn parse-int [string]\n;   (js/parseInt string))\n\n(defn println [&args]\n  (.log js/console &args))\n\n(defn print [&args]\n  (for [arg args]\n    (.write (.-stdout js/process) arg)))\n\n(defn hash-map []\n  (js/new js/Map))\n\n(defn hash-map-get [map key]\n  (.get map key))\n\n(defn hash-map-set! [map key value]\n  (.set map key value))\n\n(defn hash-map-copy [map]\n  (js/new js/Map map))\n\n(defn array-copy [array]\n  (.from js/Array array))\n\n(defn contains-key? [map key]\n  (.has map key))\n\n(def interned-symbols (hash-map))\n(def interned-keywords (hash-map))\n\n(defn string->symbol [string]\n  (if (not (contains-key? interned-symbols string))\n    (hash-map-set! interned-symbols string (js/new Symbol string)))\n  (hash-map-get interned-symbols string))\n\n(defn symbol->string [symbol]\n  (.-name symbol))\n\n(defn keyword->string [keyword]\n  (.-name keyword))\n\n(defn string->keyword [string]\n  (let [substring (if (string-prefix? string \":\")\n                    (.substring string 1)\n                    (if (string-suffix? string \":\")\n                      (.substring string 0 (- (.-length string) 1))\n                      string))]\n    (if (not (contains-key? interned-keywords substring))\n      (hash-map-set! interned-keywords substring (js/new Keyword substring)))\n    (hash-map-get interned-keywords substring)))\n\n(defn first [list]\n  (js/index list 0))\n\n(defn second [list]\n  (js/index list 1))\n\n(defn third [list]\n  (js/index list 2))\n\n(defn fourth [list]\n  (js/index list 3))\n\n(defn skip1 [list]\n  (.slice list 1))\n\n(defn skip2 [list]\n  (.slice list 2))\n\n(defn split-last [seq]\n  (js/array (.slice seq 0 (- (.-length seq) 1))\n            (js/index seq (- (.-length seq) 1))))\n\n(defn regex [str flags]\n  (js/new js/RegExp str flags))\n\n(defn error [msg]\n  (js/throw (js/new js/Error msg)))\n\n(defn tagged-list? [value tag]\n  (and (list? value)\n       (= (first value) tag)))\n\n(defn repr [value]\n  (cond\n    [(nil? value) \"nil\"]\n    [else (.stringify js/JSON value)]))\n\n(defgen grouped [seq count]\n  (loop [i 0]\n    (if (< i (.-length seq))\n      (do\n        (yield (.slice seq i (+ i count)))\n        (recur (+ i count))))))\n\n(defn zip [&arrays]\n  (map (first arrays)\n       (fn [_ index]\n         (map arrays (fn [array] (js/index array index))))))\n\n(defn set [&values]\n  (js/new js/Set values))\n\n(defn set-contains? [set value]\n  (.has set value))\n\n(defn box [value]\n  (cond\n    [(bool? value) (js/new js/Boolean value)]\n    [(number? value) (js/new js/Number value)]\n    [(string? value) (js/new js/String value)]\n    [else value]))\n\n(defn unbox [value]\n  (if (not-nil? value)\n    (.valueOf value)\n    nil))\n\n(def symbol-meta (js/Symbol \"meta\"))\n\n(defn meta [value]\n  (js/index value symbol-meta))\n\n(defn meta-set! [value meta]\n  (set! (js/index value symbol-meta) meta)\n  (js/return))\n\n(defn string-repeat [str count]\n  (.repeat str count))\n\n(defn string-pad-start [string width filler]\n  (.padStart string width filler))\n\n(defn string-pad-end [string width filler]\n  (.padEnd string width filler))\n\n(defn string [value]\n  (if (nil? value)\n    \"nil\"\n    (.toString value)))\n\n(defn max [&values]\n  (.max js/Math &values))\n; -*- mode: Clojure -*-\n\n(defn self-evaluating? [form]\n  (or (bool? form) (number? form) (string? form) (keyword? form)))\n\n(defn expand-syntax-quote [form]\n  (cond\n    [(self-evaluating? form) form]\n    [(symbol? form) (list 'quote form)]\n    [(tagged-list? form 'unquote) (second form)]\n    [(list? form) (list 'list &(map form expand-syntax-quote))]\n    [else (list 'quote form)]))\n\n(defn make-string-reader [string]\n  {input: string,\n   index: 0,\n   line: 1,\n   column: 0,\n   indent-warnings: (js/array)})\n\n(def reader-macros (hash-map))\n\n(defn reader-pos [reader]\n  {line: (.-line reader),\n   column: (.-column reader)})\n\n(defn reader-indent-warning [reader start-index end-char pos]\n  (.push (.-indentWarnings reader) {start-index: start-index, end-char: end-char, pos: pos}))\n\n(defn reader-unterminated-error [reader start-index start-pos end-char]\n  (let [warning (find-first (.-indentWarnings reader) (fn [w] (>= (.-startIndex w) start-index)))]\n    (.error js/console warning)\n    (error (+ \"Unexpected EOF, expected: '\" end-char \"'\\n\\n\"\n              \"Started here:\\n\"\n              (marked-line (.-input reader) start-pos) \"\\n\\n\"\n              \"Based on indent:\\n\"\n              (marked-line (.-input reader) (.-pos warning))))))\n\n(defn read-char [reader]\n  (let [char (js/index (.-input reader) (.-index reader))]\n    (set! (.-index reader) (+ (.-index reader) 1))\n    (if (= char \\newline)\n      (do\n        (set! (.-line reader) (+ (.-line reader) 1))\n        (set! (.-column reader) 0))\n      (set! (.-column reader) (+ (.-column reader) 1)))\n    char))\n\n(defn peek-char [reader offset]\n  (js/index (.-input reader)\n            (if (not-nil? offset)\n                (+ (.-index reader) offset)\n                (.-index reader))))\n\n(defn has-more? [reader]\n  (< (.-index reader) (.-length (.-input reader))))\n\n(defn char-whitespace? [char]\n  (or (= char \\space)\n      (= char \\tab)\n      (= char \\newline)\n      (= char \\,)))\n\n(defn char-digit? [char]\n  (and (>= char \\0)\n       (<= char \\9)))\n\n(defn char-macro? [char]\n  (contains-key? reader-macros char))\n\n(defn take-until [reader predicate]\n  (let [start-index (.-index reader)\n        input-length (.-length (.-input reader))]\n    (loop [index (.-index reader),\n           line (.-line reader),\n           column (.-column reader)]\n      (let [char (js/index (.-input reader) index)]\n        (if (or (>= index input-length)\n                (predicate char))\n          (do\n            (set! (.-index reader) index)\n            (set! (.-line reader) line)\n            (set! (.-column reader) column)\n            (.substring (.-input reader) start-index index))\n          (if (= char \\newline)\n            (recur (+ index 1) (+ line 1) 0)\n            (recur (+ index 1) line (+ column 1))))))))\n\n(defn take-while [reader predicate]\n  (take-until reader (fn [char] (not (predicate char)))))\n\n(defn skip-whitespace [reader]\n  (loop []\n    (take-while reader (fn [char] (char-whitespace? char)))\n    (if (= (peek-char reader) \\;)\n      (do\n        (take-until reader (fn [c] (= c \\newline)))\n        (recur)))))\n\n(defn read-token [reader]\n  (concat (read-char reader)\n          (take-until reader (fn (c) (or (char-whitespace? c) (char-macro? c))))))\n\n(defn parse-token [token]\n  (cond\n    [(= token \"nil\") nil]\n    [(= token \"true\") true]\n    [(= token \"false\") false]\n    [(or (string-prefix? token \":\")\n         (string-suffix? token \":\")) (string->keyword token)]\n    [else (string->symbol token)]))\n\n(defn read-number [reader]\n  (let [string (read-token reader)]\n    (if (string-contains? string \".\")\n      (js/parseFloat string)\n      (js/parseInt string))))\n\n(defn read-character [reader]\n  (let [char (read-token reader)]\n    (cond\n      [(= char \"newline\") \\newline]\n      [(= char \"return\") \\return]\n      [(= char \"tab\") \\tab]\n      [(= char \"space\") \\space]\n      [(= (.-length char) 1) char]\n      [else (error (+ \"Unrecognized char: '\" char \"'\"))])))\n\n(defn read-quote [reader first-char pos]\n  (list 'quote (read-syntax reader)))\n\n(defn read-syntax-quote [reader first-char pos]\n  (expand-syntax-quote (read-syntax reader)))\n\n(defn read-spread [reader first-char pos]\n  (list 'spread (read-syntax reader)))\n\n(defn read-unquote [reader first-char pos]\n  (list 'unquote (read-syntax reader)))\n\n(defn read-list [reader first-char pos]\n  (read-until reader \\) pos))\n\n(defn read-array [reader first-char pos]\n  (read-until reader \\] pos))\n\n(defn read-struct [reader first-char pos]\n  (list 'dict &(read-until reader \\} pos)))\n\n(defn read-unmatched-delimiter [reader first-char]\n  (error (concat \"Unmatched delimiter: \" first-char)))\n\n(defn read-string [reader first-char pos]\n  (loop [string \"\"]\n    (let [part (take-until reader (fn [ch] (or (= ch \\\")\n                                               (= ch \\\\))))\n          string2 (concat string part)\n          char (read-char reader)]\n      (cond\n        [(nil? char) (error \"Unexpected EOF while reading string\")]\n        [(= char \\\") string2]\n        [(= char \\\\)\n         (let [char (read-char reader)\n               escaped-char (cond\n                              [(nil? char) (error \"Unexpected EOF while reading character escape\")]\n                              [(= char \\\") char]\n                              [(= char \\\\) char]\n                              [(= char \\/) char]\n                              [(= char \\n) \\newline]\n                              [(= char \\t) \\tab]\n                              [(= char \\r) \\return]\n                              [(= char \\u) (read-unicode-char reader)]\n                              [else (concat (error \"Unrecognized character escape\" char))])]\n           (recur (concat string2 escaped-char)))]))))\n\n(defn read-unicode-char [reader]\n  (let [a (read-char reader),\n        b (read-char reader),\n        c (read-char reader),\n        d (read-char reader)]\n    (.fromCharCode js/String (js/parseInt (+ a b c d)))))\n\n(defn marked-line [input pos]\n  (let [line-index (- (.-line pos) 1),\n        before-line-index (- line-index 1),\n        after-line-index (+ line-index 1),\n        lines (.split input \\newline),\n        line (js/index lines line-index),\n        before-line (or (js/index lines before-line-index) \"\"),\n        after-line (or (js/index lines after-line-index) \"\"),\n        col (.-column pos),\n        caret-line (concat (string-repeat \" \" col) \"^\"),\n        line-num (string (+ line-index 1)),\n        before-line-num (string (+ before-line-index 1)),\n        after-line-num (string (+ after-line-index 1)),\n        max-line-num-width (max (.-length line-num)\n                                (.-length before-line-num)\n                                (.-length after-line-num))]\n    (+ (string-pad-start before-line-num max-line-num-width) \" \" before-line \"\\n\"\n       (string-pad-start line-num max-line-num-width) \" \" line \"\\n\"\n       (string-repeat \" \" max-line-num-width) \" \" caret-line \"\\n\"\n       (string-pad-start after-line-num max-line-num-width) \" \" after-line)))\n\n(defn reader-error [reader pos msg]\n  (error (+ msg \"\\n\\n\" (marked-line (.-input reader) pos))))\n\n(defn read-until [reader end-char start-pos]\n  (let [has-indent-error false,\n        start-index (- (.-index reader) 1),\n        start-line (.-line start-pos),\n        start-indent (.-column start-pos)]\n    (loop [results (list)]\n      (if (not has-indent-error)\n        (let [last-pos (reader-pos reader)]\n          (skip-whitespace reader)\n          (let [pos (reader-pos reader),\n                line (.-line pos),\n                indent (.-column pos)]\n            (if (and (> line start-line) (<= indent start-indent))\n              (do\n                (set! has-indent-error true)\n                (reader-indent-warning reader start-index end-char last-pos))))))\n      (let [char (peek-char reader)]\n        (cond\n          [(nil? char)\n           (reader-unterminated-error reader start-index start-pos end-char)]\n          [(= char end-char)\n           (read-char reader)\n           results]\n          [else (recur (append results (read-syntax reader)))])))))\n\n(defn read [reader pos]\n  (skip-whitespace reader)\n  (let [c (peek-char reader)]\n    (cond\n      [(char-digit? c) (read-number reader)]\n      [(char-macro? c)\n       (let [macro (hash-map-get reader-macros c)]\n         (read-char reader)\n         (macro reader c pos))]\n      [(and (or (= c \\+) (= c \\-))\n            (char-digit? (peek-char reader 1)))\n       (read-number reader)]\n      [else (parse-token (read-token reader))])))\n\n(defn read-syntax [reader]\n  (let [start-pos (reader-pos reader),\n        form (read reader start-pos),\n        end-pos (reader-pos reader)]\n    (if (not-nil? form)\n      (meta-set! form {loc: {source: (.-input reader),\n                             start: start-pos,\n                             end: end-pos}}))\n    form))\n\n(defn read-many [reader]\n  (loop [results (list)]\n    (skip-whitespace reader)\n    (if (has-more? reader)\n      (recur (append results (read-syntax reader)))\n      results)))\n\n(defn string->expr [str]\n  (read-syntax (make-string-reader str)))\n\n(defn string->exprs [str]\n  (read-many (make-string-reader str)))\n\n(hash-map-set! reader-macros \\' read-quote)\n(hash-map-set! reader-macros \\` read-syntax-quote)\n(hash-map-set! reader-macros \\& read-spread)\n(hash-map-set! reader-macros \\~ read-unquote)\n(hash-map-set! reader-macros \\\\ read-character)\n(hash-map-set! reader-macros \\\" read-string)\n(hash-map-set! reader-macros \\( read-list)\n(hash-map-set! reader-macros \\) read-unmatched-delimiter)\n(hash-map-set! reader-macros \\[ read-array)\n(hash-map-set! reader-macros \\] read-unmatched-delimiter)\n(hash-map-set! reader-macros \\{ read-struct)\n(hash-map-set! reader-macros \\} read-unmatched-delimiter)\n; -*- mode: Clojure -*-\n\n(def js-keywords (set \"var\" \"let\" \"const\"))\n\n(defn compiler-error [form msg]\n  (if (and (meta form) (.-loc (meta form)))\n    (let [loc (.-loc (meta form)),\n          source (.-source loc),\n          pos (.-start loc)]\n      (error (+ msg \"\\n\\n\" (marked-line source pos))))\n    (error msg)))\n\n(defn make-env []\n  {functions: (hash-map),\n   function-nodes: (hash-map),\n   variables: (hash-map),\n   is-loop: false})\n\n(defn child-env [env]\n  {variables: (hash-map-copy (.-variables env))\n   loop-variables: (.-loopVariables env),\n   functions: (.-functions env),\n   function-nodes: (.-functionNodes env),\n   is-loop: false})\n\n(defn recur-env [env]\n  {variables: (hash-map-copy (.-variables env))\n   loop-variables: (js/array),\n   functions: (.-functions env),\n   function-nodes: (.-functionNodes env),\n   is-loop: true})\n\n(defn replace-special-chars [ident]\n  (.replace (.replace (.replace (.replace ident \"!\" \"\")\n                                \"->\" \"-to-\")\n                      (regex \"^((contains|has).*)\\\\?$\") \"$1\")\n            (regex \"^(.*)\\\\?$\") \"is-$1\"))\n\n(defn kebabcase->camelcase [ident]\n  (.replace (replace-special-chars ident)\n            (regex \"[-_]([a-zA-Z])\" \"g\")\n            (fn [match p1] (.toUpperCase p1))))\n\n(defn sanitize-js-keywords [ident]\n  (if (js-keyword? ident)\n    (concat ident \"$\")\n    ident))\n\n(defn symbol->ident [symbol]\n  (cond\n    [(= symbol 'Symbol) \"LispSymbol\"]\n    [else (sanitize-js-keywords (kebabcase->camelcase (symbol->string symbol)))]))\n\n(defn define-variable [env symbol]\n  (let [variables (.-variables env)]\n    (if (not (contains-key? variables symbol))\n      (hash-map-set! variables symbol (symbol->ident symbol)))\n    (if (.-isLoop env)\n      (.push (.-loopVariables env) symbol))\n    (resolve-var env symbol)))\n\n(defn define-function [env name func]\n  (let [functions (.-functions env)]\n    (if (contains-key? functions name)\n      (error (+ \"Function already defined: \" (symbol->string name)))\n      (hash-map-set! functions name func))\n    nil))\n\n(defn resolve-var [env symbol]\n  (let [variables (.-variables env),\n        functions (.-functions env),\n        function-nodes (.-functionNodes env),\n        string (symbol->string symbol),\n        loc (if (meta symbol) (.-loc (meta symbol)))]\n    (cond\n      [(string-prefix? string \"js/\")\n       {type: \"Identifier\",\n        name: (.substring string 3),\n        originalName: string,\n        loc: loc}]\n      [(contains-key? variables symbol)\n       {type: \"Identifier\",\n        name: (hash-map-get variables symbol),\n        originalName: string,\n        loc: loc}]\n      [(contains-key? functions symbol)\n       (if (not (contains-key? function-nodes symbol))\n         (compile-function env (hash-map-get functions symbol)))\n       {type: \"Identifier\",\n        name: (.-ident (hash-map-get functions symbol)),\n        originalName: string,\n        loc: loc}]\n      [else\n       (compiler-error symbol (+ \"Variable or function not found: \" string \" - \"\n                                 (map (.from js/Array (.keys variables)) symbol->string) \" - \"\n                                 (map (.from js/Array (.keys functions)) symbol->string)))])))\n\n(defn compile-function [env func]\n  (let [func-env (child-env env)]\n    (hash-map-set! (.-functionNodes env)\n                   (.-name func) 'placeholder)\n    (hash-map-set! (.-functionNodes env)\n                   (.-name func)\n                   {type: \"FunctionDeclaration\",\n                    id: {type: \"Identifier\",\n                         name: (.-ident func),\n                         originalName: (symbol->string (.-name func)),\n                         loc: (.-loc (meta (.-name func)))},\n                    params: (emit-patterns func-env (.-params func)),\n                    body: (emit-return-block func-env (.-body func)),\n                    generator: (.-generator func),\n                    loc: (.-loc func)})))\n; -*- mode: Clojure -*-\n\n(def emit-specials (hash-map))\n\n;; Predicates\n\n(defn field-access? [form]\n  (and (symbol? form)\n       (string-prefix? (symbol->string form) \".-\")))\n\n(defn method-call? [form]\n  (and (symbol? form)\n       (string-prefix? (symbol->string form) \".\")))\n\n(defn special? [form]\n  (and (symbol? form)\n       (contains-key? emit-specials form)))\n\n(defn js-keyword? [ident]\n  (set-contains? js-keywords ident))\n\n(defn expression? [node]\n  (let [type (.-type node)]\n    (or (= type \"Literal\")\n        (= type \"Identifier\")\n        (string-suffix? type \"Expression\")\n        (string-suffix? type \"Element\"))))\n\n;; AST Transformation\n\n(defn statement->iife [node]\n  {type: \"CallExpression\",\n   callee: {type: \"ArrowFunctionExpression\",\n            id: nil,\n            params: (js/array),\n            body: {type: \"BlockStatement\",\n                   body: (js/array (statement->return node)),\n                   loc: (.-loc node)}},\n   arguments: (js/array)})\n\n(defn statement->expression [node]\n  (statement->iife node))\n\n(defn statements->return [nodes]\n  (if (empty? nodes)\n    (js/array {:type \"ReturnStatement\",\n               :argument nil})\n    (map-last nodes nil statement->return)))\n\n(defn statement->return [node]\n  (let [type (.-type node)]\n    (cond\n      [(= type \"ReturnStatement\") node]\n      [(= type \"ForOfStatement\") node]\n      [(= type \"ContinueStatement\") node]\n      [(= type \"ThrowStatement\") node]\n      [(= type \"ExpressionStatement\")\n       {type: \"ReturnStatement\",\n        argument: (.-expression node),\n        loc: (.-loc node)}]\n      [(= type \"BlockStatement\")\n       {type: \"BlockStatement\",\n        body: (statements->return (.-body node)),\n        loc: (.-loc node)}]\n      [(= type \"WhileStatement\")\n       {type: \"WhileStatement\",\n        test: (.-test node),\n        body: (statement->return (.-body node)),\n        loc: (.-loc node)}]\n      [(= type \"IfStatement\")\n       {type: \"IfStatement\",\n        test: (.-test node),\n        consequent: (statement->return (.-consequent node)),\n        alternate: (if (.-alternate node)\n                       (statement->return (.-alternate node))\n                       nil),\n        loc: (.-loc node)}]\n      [else (error (concat \"Unsupported return statement: \" type))])))\n\n;; AST Generation of specific types\n\n(defn emit-return-last [env forms]\n  (filter-not-nil (map-last forms (fn [form] (emit-statement env form))\n                                  (fn [form] (emit-return-statement env form)))))\n\n(defn emit-return-block [env forms]\n  {type: \"BlockStatement\",\n   body: (emit-return-last env forms)})\n\n(defn emit-return-statement [env form]\n  (let [node (emit env form)]\n    (if (expression? node)\n      {type: \"ReturnStatement\",\n       argument: node,\n       loc: (.-loc node)}\n      (statement->return node))))\n\n(defn emit-statements [env forms]\n  (map-not-nil forms (fn [form] (emit-statement env form))))\n\n(defn emit-statement [env form]\n  (let [node (emit env form)]\n    (cond\n      [(nil? node) node]\n      [(expression? node)\n       {type: \"ExpressionStatement\",\n        expression: node,\n        loc: (.-loc node)}]\n      [else node])))\n\n(defn emit-expressions [env forms]\n  (map-not-nil forms (fn [form] (emit-expression env form))))\n\n(defn emit-expression [env form]\n  (let [node (emit env form)]\n    (cond\n      [(nil? node) node]\n      [(expression? node) node]\n      [else (statement->expression node)])))\n\n(defn emit-patterns [env forms]\n  (map forms (fn [form] (emit-pattern env form))))\n\n(defn emit-pattern [env form]\n  (cond\n    [(symbol? form)\n     (define-variable env form)]\n    [(tagged-list? form 'spread)\n     {type: \"RestElement\",\n      argument: (define-variable env (second form)),\n      loc: (.-loc (meta form))}]\n    [(list? form)\n     {type: \"ArrayPattern\",\n      elements: (emit-patterns env form)}]\n    [else (compiler-error form \"Unrecognized pattern\")]))\n\n(defn emit-block [env forms]\n  (if (single? forms)\n    (emit-statement env (first forms))\n    {type: \"BlockStatement\",\n     body: (emit-statements env forms)}))\n\n;; AST Generation\n\n(defn emit-module [forms]\n  (let [env (make-env),\n        nodes (emit-statements env forms),\n        function-nodes (.-functionNodes env)]\n    {type: \"Program\",\n     body: (js/array &(.values function-nodes) &nodes)}))\n\n(defn emit [env form]\n  (cond\n    [(symbol? form) (emit-var env form)]\n    [(list? form) (emit-list env form)]\n    [else (emit-literal env form)]))\n\n(defn emit-literal [env form]\n  (cond\n    [(js/=== form js/undefined) (error \"Undefined!\")]\n    [(keyword? form) (emit env (list 'string->keyword (keyword->string form)))]\n    [(negative? form)\n     {type: \"UnaryExpression\",\n      operator: \"-\",\n      prefix: true,\n      argument: {type: \"Literal\",\n                 value: (neg (unbox form))},\n      loc: (if (and (not-nil? form) (meta form)) (.-loc (meta form)))}]\n    [else {type: \"Literal\",\n           value: (unbox form),\n           loc: (if (and (not-nil? form) (meta form)) (.-loc (meta form)))}]))\n\n(defn emit-var [env symbol]\n  (resolve-var env symbol))\n\n(defn emit-list [env form]\n  (let [loc (if (meta form) (.-loc (meta form))),\n        callee (first form),\n        args (skip1 form)]\n    (cond\n      [(field-access? callee) (emit-field env loc callee args)]\n      [(method-call? callee) (emit-methodcall env loc callee args)]\n      [(special? callee) ((hash-map-get emit-specials callee) env loc args)]\n      [else (emit-funcall env loc callee args)])))\n\n(defn emit-field [env loc callee args]\n  (let [field-name (.substring (symbol->string callee) 2)\n        obj (first args)]\n    {type: \"MemberExpression\",\n     object: (emit-expression env obj),\n     property: {type: \"Identifier\",\n                name: field-name,\n                loc: (.-loc (meta callee))},\n     computed: false,\n     loc: loc}))\n\n(defn emit-methodcall [env loc callee args]\n  (let [method-name (.substring (symbol->string callee) 1)\n        obj (first args)\n        method-args (skip1 args)]\n    {type: \"CallExpression\",\n     callee: {type: \"MemberExpression\",\n              object: (emit-expression env obj),\n              property: {type: \"Identifier\",\n                         name: method-name,\n                         loc: (.-loc (meta callee))},\n              computed: false},\n     arguments: (emit-expressions env method-args),\n     loc: loc}))\n\n(defn emit-funcall [env loc callee args]\n  {type: \"CallExpression\",\n   callee: (emit-expression env callee),\n   arguments: (emit-expressions env args),\n   loc: loc})\n\n(defn emit-defn [env loc args]\n  (let [name (first args)\n        ident (symbol->ident name)\n        params (second args)\n        rest (skip2 args)\n        docs (if (and (string? (first rest))\n                      (not-empty? (skip1 rest)))\n                 (first rest))\n        body (if docs (skip1 rest) rest)\n        func-env (child-env env)]\n    (define-function env name {name: name,\n                               ident: ident,\n                               params: params,\n                               docs: docs,\n                               body: body,\n                               loc: loc,\n                               generator: false})))\n\n(hash-map-set! emit-specials 'defn emit-defn)\n\n(defn emit-defgen [env loc args]\n  (let [name (first args)\n        ident (symbol->ident name)\n        params (second args)\n        rest (skip2 args)\n        docs (if (and (string? (first rest))\n                      (not-empty? (skip1 rest)))\n                 (first rest))\n        body (if docs (skip1 rest) rest)\n        func-env (child-env env)]\n    (define-function env name {name: name,\n                               ident: ident,\n                               params: params,\n                               docs: docs,\n                               body: body,\n                               loc: loc,\n                               generator: true})))\n\n(hash-map-set! emit-specials 'defgen emit-defgen)\n\n(defn emit-set [env loc args]\n  (let [setter (first args)\n        value (second args)]\n    (cond\n      [(symbol? setter) (emit-set-var env loc setter value)]\n      [(list? setter) (emit-setter env loc setter value)]\n      [else (error (concat \"Invalid setter: \" (repr setter)))])))\n\n(defn emit-setter [env loc setter value]\n  (let [callee (first setter)\n        args (skip1 setter)]\n    (cond\n      [(field-access? callee) (emit-set-field env loc callee args value)]\n      [(= callee 'js/index) (emit-set-index env loc args value)]\n      [else (error (concat \"Invalid setter: \" (repr setter)))])))\n\n(defn emit-set-var [env loc symbol value]\n  {type: \"AssignmentExpression\",\n   operator: \"=\",\n   left: (resolve-var env symbol),\n   right: (emit-expression env value),\n   loc: loc})\n\n(defn emit-set-field [env loc symbol args value]\n  (let [field-name (.substring (symbol->string symbol) 2)\n        obj (first args)]\n    {type: \"AssignmentExpression\",\n     operator: \"=\",\n     left: {type: \"MemberExpression\",\n            object: (emit-expression env obj),\n            property: {type: \"Identifier\",\n                       name: field-name,\n                       loc: (.-loc (meta symbol))},\n            computed: false},\n     right: (emit-expression env value),\n     loc: loc}))\n\n(defn emit-set-index [env loc args value]\n  (let [obj (first args)\n        index (second args)]\n    {type: \"AssignmentExpression\",\n     operator: \"=\",\n     left: {type: \"MemberExpression\",\n            object: (emit-expression env obj),\n            property: (emit-expression env index),\n            computed: true},\n     right: (emit-expression env value),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'set! emit-set)\n\n(defn emit-bin-op [op]\n  (fn [env loc args]\n    (if (empty? args)\n      (error \"Empty operator expression\"))\n    (.reduce (emit-expressions env args)\n            (fn [acc, arg]\n              {type: \"BinaryExpression\",\n               operator: op,\n               left: acc,\n               right: arg,\n               loc: loc}))))\n\n(hash-map-set! emit-specials 'and (emit-bin-op \"&&\"))\n(hash-map-set! emit-specials 'or (emit-bin-op \"||\"))\n(hash-map-set! emit-specials 'js/and (emit-bin-op \"&&\"))\n(hash-map-set! emit-specials 'js/or (emit-bin-op \"||\"))\n(hash-map-set! emit-specials 'js/=== (emit-bin-op \"===\"))\n(hash-map-set! emit-specials 'js/!== (emit-bin-op \"!==\"))\n(hash-map-set! emit-specials 'js/== (emit-bin-op \"==\"))\n(hash-map-set! emit-specials 'js/!= (emit-bin-op \"!=\"))\n(hash-map-set! emit-specials '= (emit-bin-op \"===\"))\n(hash-map-set! emit-specials '!= (emit-bin-op \"!==\"))\n(hash-map-set! emit-specials '>= (emit-bin-op \">=\"))\n(hash-map-set! emit-specials '<= (emit-bin-op \"<=\"))\n(hash-map-set! emit-specials '> (emit-bin-op \">\"))\n(hash-map-set! emit-specials '< (emit-bin-op \"<\"))\n(hash-map-set! emit-specials '+ (emit-bin-op \"+\"))\n(hash-map-set! emit-specials '- (emit-bin-op \"-\"))\n(hash-map-set! emit-specials '* (emit-bin-op \"*\"))\n(hash-map-set! emit-specials '/ (emit-bin-op \"/\"))\n(hash-map-set! emit-specials 'mod (emit-bin-op \"%\"))\n(hash-map-set! emit-specials 'js/instanceof (emit-bin-op \"instanceof\"))\n\n(defn emit-spread [env loc args]\n  {type: \"SpreadElement\",\n   argument: (emit-expression env (first args)),\n   loc: loc})\n\n(hash-map-set! emit-specials 'spread emit-spread)\n\n(defn emit-array [env loc args]\n  {type: \"ArrayExpression\",\n   elements: (emit-expressions env args),\n   loc: loc})\n\n(hash-map-set! emit-specials 'js/array emit-array)\n\n(defn emit-fn [env loc args]\n  (let [params (first args)\n        body (skip1 args)\n        func-env (child-env env)]\n    {type: \"ArrowFunctionExpression\",\n     id: nil,\n     params: (emit-patterns func-env params),\n     body: (emit-return-block func-env body),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'fn emit-fn)\n\n(defn emit-if [env loc args]\n  (let [test (first args)\n        if-true (second args)\n        if-false (skip2 args)]\n    {type: \"IfStatement\",\n     test: (emit-expression env test),\n     consequent: (emit-statement env if-true),\n     alternate: (if (not-nil? if-false) (emit-block env if-false)),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'if emit-if)\n\n(defn emit-for [env loc args]\n  (let [var (first (first args))\n        value (second (first args))\n        body (skip1 args)\n        for-env (child-env env)]\n    {type: \"ForOfStatement\",\n     left: (emit-pattern for-env var),\n     right: (emit-expression for-env value),\n     body: (emit-block for-env body),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'for emit-for)\n\n(defn emit-def [env loc args]\n  {type: \"VariableDeclaration\",\n   kind: \"let\",\n   declarations: (js/array {type: \"VariableDeclarator\",\n                            id: (define-variable env (first args)),\n                            init: (emit-expression env (second args)),\n                            loc: loc}),\n   loc: loc})\n\n(hash-map-set! emit-specials 'def emit-def)\n\n(defn emit-vars [env vars]\n  {type: \"VariableDeclaration\",\n   kind: \"let\",\n   declarations: (map (.from js/Array (grouped vars 2))\n                      (fn [pair]\n                        {type: \"VariableDeclarator\",\n                         id: (define-variable env (first pair)),\n                         init: (emit-expression env (second pair))})),\n   loc: (.-loc (meta vars))})\n\n(defn emit-let [env loc args]\n  (let [vars (first args)\n        body (skip1 args)\n        let-env (child-env env)]\n    {type: \"BlockStatement\",\n     body: (js/array (emit-vars let-env vars) &(emit-statements let-env body)),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'let emit-let)\n\n(defn emit-cond [env loc args]\n  (let [expr (first args),\n        rest (skip1 args),\n        test (first expr),\n        body (skip1 expr)]\n    (if (= test 'else)\n      (emit-block env body)\n      {type: \"IfStatement\",\n       test: (emit-expression env test),\n       consequent: (emit-block env body),\n       alternate: (if (not-empty? rest) (emit-cond env loc rest))})))\n\n(hash-map-set! emit-specials 'cond emit-cond)\n\n(defn emit-loop [env loc args]\n  (let [vars (first args)\n        body (skip1 args)\n        loop-env (recur-env env)]\n    (if (empty? vars)\n      {type: \"WhileStatement\",\n       test: (emit-literal loop-env true),\n       body: (emit-return-block loop-env body)}\n      {type: \"BlockStatement\",\n       body: (js/array (emit-vars loop-env vars)\n                       {type: \"WhileStatement\",\n                        test: (emit-literal loop-env true),\n                        body: (emit-return-block loop-env body)})})))\n\n(hash-map-set! emit-specials 'loop emit-loop)\n\n(defn emit-do [env loc args]\n  {type: \"BlockStatement\",\n   body: (emit-statements env args),\n   loc: loc})\n\n(hash-map-set! emit-specials 'do emit-do)\n\n(defn emit-yield [env loc args]\n  {type: \"YieldExpression\",\n   argument: (emit-expression env (first args)),\n   loc: loc})\n\n(hash-map-set! emit-specials 'yield emit-yield)\n\n(defn emit-recur [env loc args]\n  (if (!= (.-length (.-loopVariables env)) (.-length args))\n    (error (+ \"Recur with not enough args\" (.-length (.-loopVariables env)) (.-length args))))\n  (if (empty? args)\n    {type: \"ContinueStatement\",\n     loc: loc}\n    {type: \"BlockStatement\",\n     body: (js/array &(map (zip (.-loopVariables env) args)\n                           (fn [pair]\n                             {type: \"ExpressionStatement\",\n                              expression: {type: \"AssignmentExpression\",\n                                           operator: \"=\",\n                                           left: (emit-pattern env (first pair)),\n                                           right: (emit-expression env (second pair))}}))\n                    {type: \"ContinueStatement\"}),\n     loc: loc}))\n\n(hash-map-set! emit-specials 'recur emit-recur)\n\n(defn emit-dict [env ctx args]\n  {type: \"ObjectExpression\",\n   properties: (map (.from js/Array (grouped args 2))\n                    (fn [pair]\n                      {type: \"Property\",\n                       key: (if (keyword? (first pair))\n                              (emit-literal env (kebabcase->camelcase (keyword->string (first pair))))\n                              (emit-literal env (first pair))),\n                       value: (emit-expression env (second pair))}))})\n\n(hash-map-set! emit-specials 'dict emit-dict)\n\n(defn emit-quote [env loc args]\n  (emit env (knight-quote (first args))))\n\n(defn knight-quote [form]\n  (cond\n    [(symbol? form) (list 'string->symbol (symbol->string form))]\n    [(list? form) (list 'js/array &(map form knight-quote))]\n    [else form]))\n\n(hash-map-set! emit-specials 'quote emit-quote)\n\n(defn emit-return [env loc args]\n  {type: \"ReturnStatement\",\n   argument: (if (not-empty? args)\n               (emit-expression env (first args))\n               nil),\n   loc: loc})\n\n(hash-map-set! emit-specials 'js/return emit-return)\n\n(defn emit-throw [env loc args]\n  {type: \"ThrowStatement\",\n   argument: (emit-expression env (first args)),\n   loc: loc})\n\n(hash-map-set! emit-specials 'js/throw emit-throw)\n\n(defn emit-new [env loc args]\n  {type: \"NewExpression\",\n   callee: (emit-expression env (first args)),\n   arguments: (emit-expressions env (skip1 args)),\n   loc: loc})\n\n(hash-map-set! emit-specials 'js/new emit-new)\n\n(defn emit-index [env ctx args]\n  (let [obj (first args)\n        index (second args)]\n    {type: \"MemberExpression\",\n     object: (emit-expression env obj),\n     property: (emit-expression env index),\n     computed: true}))\n\n(hash-map-set! emit-specials 'js/index emit-index)\n; -*- mode: Clojure -*-\n(js/require \"source-map-support/register\")\n\n(def fs (js/require \"fs\"))\n(def path (js/require \"path\"))\n(def escodegen (js/require \"escodegen\"))\n(def terser (js/require \"terser\"))\n(def program (.-program (js/require \"commander\")))\n\n(.option program \"-o, --output <filename>\" \"Output JS filename\")\n(.option program \"-m, --map\" \"Generate source maps\")\n\n(.parse program (.-argv js/process))\n\n(let [output-filename (.-output program),\n      output-dirname (if output-filename (.dirname path output-filename)),\n      source-map-filename (if (.-map program) (if output-filename (+ (.basename path output-filename) \".map\") \"inline\")),\n      code (.readFileSync fs 0 \"utf-8\"),\n      forms (string->exprs code),\n      ast (emit-module forms),\n      output (.generate escodegen ast {sourceMap: \"stdin\", sourceMapWithCode: true, sourceContent: code}),\n      source-map (.toString (.-map output)),\n      minified (.minify terser (.-code output) {toplevel: true,\n                                                sourceMap: (if source-map-filename\n                                                             {content: source-map, url: source-map-filename})})]\n  (if (.-error minified)\n    (.error js/console (.-error minified))\n    (if output-filename\n      (do\n        (.writeFileSync fs output-filename (.-code minified))\n        (if (and source-map-filename (!= source-map-filename \"inline\"))\n          (.writeFileSync fs (.join path output-dirname source-map-filename) (.toString (.-map minified)))))\n      (println (.-code minified)))))\n"]}