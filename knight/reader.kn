; -*- mode: Clojure -*-

(defn make-string-reader [string]
  {input: string,
   index: 0})

(def reader-macros (hash-map))

(defn reader-pos [reader]
  (let [line-break (regex "\r\n?|\n","g")]
    (loop [line 1,
           cur 0]
      (set! (.-lastindex line-break) cur)
      (let [match (.exec line-break (.-input reader))]
        (if (and match (< (.-index match) (.-index reader)))
          (recur (+ line 1)
                 (+ (.-index match) (.-length (js/index match 0))))
          {line: line,
           column: (- (.-index reader) cur)})))))

(defn read-char [reader]
  (let [char (js/index (.-input reader) (.-index reader))]
    (set! (.-index reader) (+ (.-index reader) 1))
    char))

(defn peek-char [reader]
  (js/index (.-input reader) (.-index reader)))

(defn has-more? [reader]
  (< (.-index reader) (.-length (.-input reader))))

(defn char-whitespace? [char]
  (or (= char \space)
      (= char \tab)
      (= char \newline)
      (= char \,)))

(defn char-digit? [char]
  (and (>= char \0)
       (<= char \9)))

(defn char-macro? [char]
  (contains-key? reader-macros char))

(defn take-until [reader predicate]
  (let [start-index (.-index reader)
        input-length (.-length (.-input reader))]
    (loop [index (.-index reader)]
      (if (or (>= index input-length)
              (predicate (js/index (.-input reader) index)))
        (do
          (set! (.-index reader) index)
          (.substring (.-input reader) start-index index))
        (recur (+ index 1))))))

(defn take-while [reader predicate]
  (take-until reader (fn [char] (not (predicate char)))))

(defn skip-whitespace [reader]
  (loop []
    (take-while reader (fn [char] (char-whitespace? char)))
    (if (= (peek-char reader) \;)
      (do
        (take-until reader (fn [c] (= c \newline)))
        (recur)))))

(defn read-token [reader]
  (concat (read-char reader)
          (take-until reader (fn (c) (or (char-whitespace? c) (char-macro? c))))))

(defn parse-token [token]
  (cond
    [(= token "nil") nil]
    [(= token "true") true]
    [(= token "false") false]
    [(or (string-prefix? token ":")
         (string-suffix? token ":")) (string->keyword token)]
    [else (string->symbol token)]))

(defn read-number [reader]
  (let [string (read-token reader)]
    (if (string-contains? string ".")
      (js/parseFloat string)
      (js/parseInt string))))

(defn read-character [reader]
  (let [char (read-token reader)]
    (cond
      [(= char "newline") \newline]
      [(= char "return") \return]
      [(= char "tab") \tab]
      [(= char "space") \space]
      [(= (.-length char) 1) char]
      [else (error (+ "Unrecognized char: '" char "'"))])))

(defn read-quote [reader]
  (list 'quote (read reader)))

(defn read-list [reader first-char]
  (read-until reader \)))

(defn read-array [reader first-char]
  (read-until reader \]))

(defn read-struct [reader first-char]
  (list 'dict (spread (read-until reader \}))))

(defn read-unmatched-delimiter [reader first-char]
  (error (concat "Unmatched delimiter: " first-char)))

(defn read-string [reader first-char]
  (loop [string ""]
    (let [part (take-until reader (fn [ch] (or (= ch \")
                                               (= ch \\))))
          string2 (concat string part)
          char (read-char reader)]
      (cond
        [(nil? char) (error "Unexpected EOF while reading string")]
        [(= char \") string2]
        [(= char \\)
         (let [char (read-char reader)
               escaped-char (cond
                              [(nil? char) (error "Unexpected EOF while reading character escape")]
                              [(= char \") char]
                              [(= char \\) char]
                              [(= char \/) char]
                              [(= char \n) \newline]
                              [(= char \t) \tab]
                              [(= char \r) \return]
                              [(= char \u) (read-unicode-char reader)]
                              [else (concat (error "Unrecognized character escape" char))])]
           (recur (concat string2 escaped-char)))]))))

(defn read-unicode-char [reader]
  (let [a (read-char reader),
        b (read-char reader),
        c (read-char reader),
        d (read-char reader)]
    (.fromCharCode js/String (js/parseInt (+ a b c d)))))

(hash-map-set! reader-macros \' read-quote)
(hash-map-set! reader-macros \\ read-character)
(hash-map-set! reader-macros \" read-string)
(hash-map-set! reader-macros \( read-list)
(hash-map-set! reader-macros \) read-unmatched-delimiter)
(hash-map-set! reader-macros \[ read-array)
(hash-map-set! reader-macros \] read-unmatched-delimiter)
(hash-map-set! reader-macros \{ read-struct)
(hash-map-set! reader-macros \} read-unmatched-delimiter)

(defn read-until [reader end-char]
  (loop [results (list)]
    (skip-whitespace reader)
    (let [char (peek-char reader)]
      (cond
        [(nil? char) (error (+ "Unexpected EOF, expected: " end-char))]
        [(= char end-char)
         (read-char reader)
         results]
        [else (recur (append results (read-syntax reader)))]))))

(defn read [reader]
  (skip-whitespace reader)
  (let [c (peek-char reader)]
    (cond
      [(char-digit? c) (read-number reader)]
      [(char-macro? c)
       (let [macro (hash-map-get reader-macros c)]
         (read-char reader)
         (macro reader c))]
      [else (parse-token (read-token reader))])))

(defn read-syntax [reader]
  (let [start-pos (reader-pos reader),
        form (read reader),
        end-pos (reader-pos reader)]
    (if (not-nil? form)
      (meta-set! form {}));{source: (.-input reader),
                ;  start: start-pos,
                ;  end: end-pos}))
    form))

(defn read-many [reader]
  (loop [results (list)]
    (skip-whitespace reader)
    (if (has-more? reader)
      (recur (append results (read-syntax reader)))
      results)))

(defn string->expr [str]
  (read-syntax (make-string-reader str)))

(defn string->exprs [str]
  (read-many (make-string-reader str)))
